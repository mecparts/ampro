   1:					;ABS
   2:				; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   3:				; *								*
   4:				; *  AMPRO Computers, Inc.			BIOS Version 4  *
   5:				; *								*
   6:				; *	        Copyright (C) 1983,1984,1985,1986               *
   7:				; *                    AMPRO Computers, Inc.                    *
   8:				; *			All rights reserved.			*
   9:				; *								*
  10:				; *  This BIOS is designed for use with AMPRO hardware only.	*
  11:				; *  All other use is prohibited without prior written consent	*
  12:				; *  from AMPRO Computers, Inc.					*
  13:				; *								*
  14:				; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  15:				;
  16:				; Floppy-related features:
  17:				;
  18:				;   o	Automatic sensing of 4 AMPRO formats
  19:				;
  20:				;   o	Automatic 48tpi (double-stepping) support in 96tpi drives.
  21:				;	WARNING:  writes are allowed, but not recommended.
  22:				;
  23:				;   o	"E-drive" supports wide variety of non-AMPRO formats
  24:				;
  25:				;   o	Console beeps on attempt to read/write a drive without a
  26:				;	floppy in it, but only on first access since CTRL-C.
  27:				;
  28:				;   o	A step rate per physical drive is now supported, and 2ms and
  29:				;	3ms step rates are supported with the 1772 FDC.
  30:				;
  31:				;   o	8" data rates implemented on a per logical drive basis.
  32:				;	NOTE: Most 1770/1772 FDC chips cannot support this rate.
  33:				;
  34:				; Hard-disk related features:
  35:				;
  36:				;   o	Hard disk support is SCSI generic and installed by HINIT
  37:				;	as a run-time option, or by boot EPROM after use of HGEN.
  38:				;
  39:				;   o	Bus (SCSI) arbitration is an assembly-time option.
  40:				;
  41:				;   o	Each hard disk partition has its own DPB, which allows
  42:				;	flexible partitioning of any disk drive, up to 88Mb.
  43:				;
  44:				;   o	A direct SCSI call is available as an extended BIOS JMP.
  45:				;
  46:				;   o	A SCSI burst/byte option allows some controllers to 
  47:				;	operate at optimum rates.  Set by HINIT.
  48:				;
  49:				; Other features:
  50:				;
  51:				;   o	Generic ZCPR3 support.  Easily extendable via the AMPRO 
  52:				;	EXTENDED ZCPR3 PACKAGES. 
  53:				;
  54:				;   o	Buffered serial I/O, via interrupts.
  55:				;
  56:				;   o   Real time NOVAdos compatible clock, via interrupts.
  57:				;
  58:				;	*	*	*	*	*	*	*	*
  59:				;
  60:				;  Revision history:
  61:				;
  62:				;  Ver	Date	Who	Description
  63:				;  ---	-----	---	------------------------------------------
  64:				;  4.3  210816  SWH     - Update Z3ENV
  65:				;			- Rearrange SIO register initialization
  66:				;			  sequence and get SIO statii properly updated
  67:				;			  at power up
  68:				;			- Put PiGFX terminal into Wordstar mode at
  69:				;			  power up
  70:				;
  71:				;  4.2	900326	SWH	- interrupt driven serial output for chan B
  72:				;			(for increased throughput at high baud rates)
  73:				;
  74:				;  4.1	900213	SWH	Clock routine now 1 second interrupt
  75:				;			Interrupt driven serial input
  76:				;			Interrupts disabled during disk I/O
  77:				;			Parity bit not stripped from reader input
  78:				;			Extended BIOS calls for reader input status,
  79:				;			punch output status, sending BREAK to modem
  80:				;			
  81:				;  4.0  890504  SWH     Converted to Z80 mnemonics
  82:				;			Clock routine changed for NOVAdos
  83:				;			Removed conditional assembly stuff I didn't use
  84:				;			Corrected potential bug around SBOOT label
  85:				;
  86:				;  3.8  F4.10   FSW	Now include Initiator SCSI ID in select.
  87:				;			Added SCSI I/O retries.
  88:				;  			Added buffered console and RTC options.
  89:				;			Added local stack for above two options.
  90:				;			Fixed problem in SELEND routine. 
  91:				;			Various speed ups and clean ups. 
  92:				;			BEEP is now an option.
  93:				;			improved WBOOT option for ZRDOS+.
  94:				;			Now clear PUBLIC bytes for ZRDOS+.
  95:				;
  96:				;  3.5 - 3.7		Internal unreleased versions
  97:				;
  98:				;  3.4	EA.30	RJB	Moved SCSI mode byte out of buffer area.
  99:				;		RBL	Added bios hooks for ZCPR3 IOP.  Added
 100:				;			floppy control parameters to cold boot
 101:				;			code.  Set "startup" as standard cold boot
 102:				;			command (AUTOCMD).  Modified SCSI routines
 103:				;			to provide better internal status when in
 104:				;			a multi-master environment.  Changed SCSI
 105:				;			bus reset to assembly option (new SCSI 
 106:				;			boot EPROM does it -- if BIOS does it
 107:				;			again, problems can occur.)
 108:				;
 109:				;  3.3	E8.21	RJB	Changed RESTORE logic to wait longer for
 110:				;			the FDC to setup.  Corrected sector number
 111:				;			problem with Kaypro 4/10 format.  Added
 112:				;			routine to set memory from the end of BIOS
 113:				;			thru 0FFFFH to zero in order to support
 114:				;			ZCPR3 resident system segment options (RCP
 115:				;			FCP, IOP, etc).
 116:				;
 117:				;  3.2	E7.30	RJB	Removed 2 nested "IF" statements in the 
 118:				;			hard disk section which generated extra 
 119:				;			(unused) code in the floppy-only version.
 120:				;			NO FUNCTIONAL CHANGES.
 121:				;
 122:				;  3.1	E7.02	RJB	Production release of version 3 bios.
 123:				;
 124:				;  3.0	E5.21	RJB	Beta release of version 3 bios.
 125:				;
 126:				;	*	*	*	*	*	*	*	*
 127:				; Bios version and date
 128:				
 129:     -	002B          	VERS		EQU	43		; Current version
 130:				
 131:				; Customization equates:
 132:				
 133:						; The following equate determines the amount of system memory 
 134:						; available for hard disk buffers and other options:
 135:     -	003A          	MSIZE	EQU	58
 136:						; 59K = Floppy + 10Mb Hard
 137:						; 58K = Floppy + 42Mb Hard
 138:						; 57K = Floppy + 74Mb Hard
 139:						; 56K = Floppy + 88Mb Hard
 140:				
 141:     -	0040          	KEYSIZE	EQU	64		; size of keyboard serial input buffer (<256)
 142:     -	00AA          	MdmIsize	equ	170	; size of modem serial input buffer (<256)
 143:     -	00AA          	MdmOsize	equ	170	; size of modem serial output buffer (<256)
 144:				
 145:				; CP/M internals
 146:				
 147:     -	9800          	BIAS		EQU	(MSIZE-20)*1024	; CP/M bias
 148:     -	CC00          	CCP		EQU	3400H+BIAS	; CCP  starting address
 149:     -	D406          	BDOS		EQU	CCP+806H	; BDOS starting address
 150:     -	E200          	BIOS		EQU	CCP+1600H	; BIOS starting address
 151:     -	0010          	NSECTS		EQU	(BDOS-CCP)/128	; warm boot sector count
 152:				
 153:				; CP/M externals
 154:				
 155:     -	0004          	CDISK		EQU	0004H		; Current disk: 0=A,...,15=P
 156:     -	0003          	IOBYTE		EQU	0003H		; Intel I/O byte
 157:				
 158:				; CP/M to host disk constants
 159:				
 160:     -	0000          	WRALL		EQU	0		; Write to allocated
 161:     -	0001          	WRDIR		EQU	1		; Write to directory
 162:     -	0002          	WRUAL		EQU	2		; Write to unallocated
 163:				
 164:				; Ampro hardware port equates
 165:				
 166:     -	0000          	CONT	EQU	00H		; Ampro system control port
 167:				
 168:     -	0001          	PIO1	EQU	001H		; Parallel printer
 169:     -	0002          	STBSET	EQU	002H		; Set print strobe
 170:     -	0003          	STBCLR	EQU	003H		; Clear print strobe
 171:				
 172:     -	0040          	CTCA0	EQU	040H		; Clock/timer channel 0
 173:     -	0050          	CTCA1	EQU	050H		; Clock/timer channel 1
 174:     -	0060          	CTCA2	EQU	060H		; Clock/timer channel 2
 175:     -	0070          	CTCA3	EQU	070H		; Clock/timer channel 3
 176:				
 177:     -	0080          	SIODPA	EQU	080H		; Serial port A - data
 178:     -	0084          	SIOCPA	EQU	084H		; Serial port A - control
 179:     -	0088          	SIODPB	EQU	088H		; Serial port B - data
 180:     -	008C          	SIOCPB	EQU	08CH		; Serial port B - control
 181:				
 182:     -	00C0          	CMND	EQU	0C0H		; Disk controller command
 183:     -	00C1          	WTRK	EQU	CMND+1		; Disk controller write track
 184:     -	00C2          	WSEC	EQU	CMND+2		; Disk controller write sector
 185:     -	00C3          	WDAT	EQU	CMND+3		; Disk controller write data
 186:				
 187:     -	00C4          	STAT	EQU	0C4H		; Disk controller status
 188:     -	00C5          	RTRK	EQU	STAT+1		; Disk controller read track
 189:     -	00C6          	RSEC	EQU	STAT+2		; Disk controller read sector
 190:     -	00C7          	RDAT	EQU	STAT+3		; Disk controller read data
 191:				
 192:				; DART masks
 193:				
 194:     -	0001          	RDA	EQU	01H		; DART recieve data available
 195:     -	0004          	TBE	EQU	04H		; DART transmit buffer empty
 196:     -	0008          	DCD	EQU	08H		; DART data carrier detect
 197:     -	0010          	PRTRDY	EQU	10H		; Printer BUSY line
 198:     -	0020          	CTS	EQU	20H		; DART clear to send
 199:				
 200:				; FDC masks, commands, and constants
 201:				
 202:     -	0008          	FRESTOR EQU	008H		; FDC restore
 203:     -	0018          	FSEEKNV EQU	018H		; FDC seek, no verify
 204:     -	001C          	FSEEK	EQU	01CH		; FDC seek, with verify
 205:     -	0088          	FREADS	EQU	088H		; FDC read sector
 206:     -	00A8          	FWRITES EQU	0A8H		; FDC write sector
 207:     -	00C8          	FRDADDR EQU	0C8H		; FDC read address
 208:				
 209:     -	0008          	FNS	EQU	008H		; 0=spin-up,   1=no spin-up
 210:     -	0004          	FVF	EQU	004H		; 0=no verify, 1=verify
 211:     -	0002          	FNP	EQU	002H		; 0=precomp,   1=no precomp
 212:				
 213:     -	0003          	FRETRY	EQU	3		; Number of floppy retries
 214:     -	0023          	HLDELAY EQU	35		; Head load delay (ms)
 215:     -	0010          	DSBIAS	EQU	16		; Double sided sector bias
 216:				
 217:				; Disk type byte definitions:
 218:				
 219:						; 	   Bit: 76543210
 220:						; Density	x	   0=single     1=double
 221:						; Sides		 x	   0=single     1=double
 222:						; Sector #'s	  x	   0=same       1=continuous
 223:						; Track count	   x	   0=down       1=down front, up back
 224:						; Alloc unit	    xx	   00=1K   01=2K   10=4K   11=8K
 225:						; Sector size	      xx   00=128  01=256  10=512  11=1024
 226:						; 	   Bit: 76543210
 227:				
 228:     -	0086          	SSDD48	EQU	10000110B	; DD,SS,same,down,2K,512
 229:     -	00C6          	DSDD48	EQU	11000110B	; DD,DS,same,down,2K,512
 230:     -	0087          	SSDD96	EQU	10000111B	; DD,SS,same,down,2K,1024
 231:     -	00C7          	DSDD96	EQU	11000111B	; DD,DS,same,down,2K,1024
 232:				
 233:				;  NCR controller equates
 234:				
 235:     -	0020          	NCRBASE EQU	20H		; Base address of NCR 5380
 236:     -	0020          	NCRCSD	EQU	NCRBASE+0	; (R)  Current SCSI data register
 237:     -	0020          	NCRODR	EQU	NCRBASE+0	; (W)  Output data register
 238:     -	0021          	NCRICR	EQU	NCRBASE+1	; (RW) Initiator command register
 239:     -	0022          	NCRMR	EQU	NCRBASE+2	; (RW) Mode register
 240:     -	0023          	NCRTCR	EQU	NCRBASE+3	; (RW) Target command register
 241:     -	0024          	NCRCSBS EQU	NCRBASE+4	; (R)  Current SCSI bus status
 242:     -	0024          	NCRSER	EQU	NCRBASE+4	; (W)  Select enable register
 243:     -	0025          	NCRBSR	EQU	NCRBASE+5	; (R)  Bus & status register
 244:     -	0025          	NCRSDS	EQU	NCRBASE+5	; (W)  Start DMA send
 245:     -	0026          	NCRIDR	EQU	NCRBASE+6	; (R)  Input data register
 246:     -	0026          	NCRSDTR EQU	NCRBASE+6	; (W)  Start DMA target receive
 247:     -	0027          	NCRRPI	EQU	NCRBASE+7	; (R)  Reset parity/interrupt
 248:     -	0027          	NCRSDIR EQU	NCRBASE+7	; (W)  Start DMA initiator receive
 249:     -	0028          	NCRDACK EQU	NCRBASE+8	; (RW) DACK pseudo-DMA register
 250:				
 251:     -	0008          	BSYBIT	EQU	08H
 252:     -	0002          	ERROR	EQU	02H
 253:				
 254:				; Current SCSI bus status (NCRCSBS)
 255:				
 256:     -	0080          	NCRRST	EQU	10000000B	; Reset
 257:     -	0040          	NCRBSY	EQU	01000000B	; Busy
 258:     -	0020          	NCRREQ	EQU	00100000B	; Request
 259:     -	0010          	NCRMSG	EQU	00010000B	; Message
 260:     -	0008          	NCRCD	EQU	00001000B	; Control/Data
 261:     -	0004          	NCRIO	EQU	00000100B	; Input/Output
 262:     -	0002          	NCRSEL	EQU	00000010B	; Select
 263:     -	0001          	NCRDBP	EQU	00000001B	; Data bus parity
 264:				
 265:				; Character equates
 266:				
 267:     -	0003          	CTRLC	EQU	'C'-'@'		; Ctrl-C (Break, abort)
 268:     -	0007          	BELL	EQU	'G'-'@'		; Ctrl-G (Bell)
 269:     -	0008          	BSP	EQU	'H'-'@'		; Ctrl-H (Backspace)
 270:     -	0009          	TAB	EQU	'I'-'@'		; Ctrl-I (Tab)
 271:     -	000A          	LF	EQU	'J'-'@'		; Ctrl-J (Line feed)
 272:     -	000D          	CR	EQU	'M'-'@'		; Ctrl-M (Carriage return)
 273:     -	0015          	NAK	EQU	'U'-'@'		; Ctrl-U
 274:     -	0018          	CAN	EQU	'X'-'@'		; Ctrl-X (Cancel)
 275:     -	001B          	ESC	EQU	1BH		; Ctrl-[ (Escape)
 276:     -	007F          	DEL	EQU	7FH		; 	 (Delete)
 277:				
 278:				; Other equates
 279:				
 280:     -	001C          	DELSEND EQU	28
 281:     -	0028          	DDLSPT	EQU	40
 282:				
 283:				; ZCPR3 equates
 284:				
 285:     -	0021          	Z3REV	EQU	33		; ZCPR 3.3
 286:				
 287:     -	FFD0          	EXTSTK	EQU	0FFD0H		; Z3 external stack
 288:				
 289:     -	FF00          	Z3CL	EQU	0FF00H		; Z3 command line buffer
 290:     -	00C8          	Z3CLS	EQU	200		; Size in bytes
 291:				
 292:     -	FE00          	Z3ENV	EQU	0FE00H		; Z3 environment descriptor
 293:     -	0002          	Z3ENVS	EQU	2		; Size in 128-byte blocks
 294:				
 295:     -	FDD0          	EXTFCB	EQU	0FDD0H		; Z3 external FCB
 296:				
 297:     -	FD80          	Z3MSG	EQU	0FD80H		; Z3 message buffers
 298:				
 299:     -	FD00          	SHSTK	EQU	0FD00H		; Shell stack
 300:     -	0004          	SHSTKS	EQU	4		; Number of shell elements
 301:     -	0020          	SHSIZE	EQU	32		; Size of a shell entry
 302:				
 303:     -	FC00          	Z3NDIR	EQU	0FC00H		; Named directory area
 304:     -	000E          	Z3NDIRS EQU	14		; Size in 18-byte blocks
 305:				
 306:     -	F900          	FCP	EQU	0F900H		; Flow command package
 307:     -	0006          	FCPS	EQU	6		; Size in 128-byte blocks
 308:				
 309:     -	0000          	RCP	EQU	00000H		; Resident command package
 310:     -	0000          	RCPS	EQU	0		; Size in 128-byte blocks
 311:				
 312:     -	0000          	IOP	EQU	00000H		; Redirectable I/O package
 313:     -	0000          	IOPS	EQU	0		; Size in 128-byte blocks
 314:				
 315:     -	0040          	EXPATH	EQU	40H		; Location of exernal path
 316:     -	0005          	EXPATHS EQU	5		; 5 2-byte path elements
 317:				
 318:     -	004B          	Z3WHL	EQU	4BH		; Wheel byte location
 319:				
 320:     -	F900          	Z3BASE	EQU	0F900H
 321:				;	*	*	*	*	*	*	*	*
 322:				;
 323:				;		C A V E A T    E M P T O R
 324:				;
 325:				;  WARNING: The address offsets from BIOS thru BIOS+017FH must remain
 326:				;  the same.  Any changes in these offsets will cause incompatibility
 327:				;  with the AMPRO system utilities.
 328:				;
 329:				;		  YOU HAVE BEEN WARNED ...
 330:				;
 331:				;	*	*	*	*	*	*	*	*
 332:				
 333:     -	E200          		ORG	BIOS		; Bios starting location
 334:				
 335:    0+10	E200  C30BEF  		JP	BOOT		; Cold start
 336:   10+10	E203  C325E5  	WBOOTE:	JP	WBOOT		; Warm start
 337:   20+10	E206  C37DEA  		JP	CONST		; Console status
 338:   30+10	E209  C38DEA  		JP	CONIN		; Console character in
 339:   40+10	E20C  C3A1EA  		JP	CONOUT		; Console character out
 340:   50+10	E20F  C39CEB  		JP	LSTOUT		; List character out
 341:   60+10	E212  C306EB  		JP	PUNCH		; Punch character out
 342:   70+10	E215  C32BEB  		JP	READER		; Reader character in
 343:   80+10	E218  C366E4  		JP	HOME		; Seek to home position
 344:   90+10	E21B  C390E4  		JP	SELDSK		; Select disk
 345:  100+10	E21E  C376E4  		JP	SETTRK		; Set track number
 346:  110+10	E221  C37FE4  		JP	SETSEC		; Set sector number
 347:  120+10	E224  C387E4  		JP	SETDMA		; Set DMA address
 348:  130+10	E227  C399E6  		JP	READ		; Read disk
 349:  140+10	E22A  C3B9E6  		JP	WRITE		; Write disk
 350:  150+10	E22D  C384EB  		JP	LISTST		; Return list status
 351:  160+10	E230  C38DE4  		JP	SECTRAN		; Sector translate
 352:				
 353:				; Ampro specific bios calls
 354:				
 355:  170+10	E233  C384E3  		JP	GETTBL		; Point to more jumps
 356:  180+10	E236  C3A8E3  		JP	GETEDSK		; Get ptr to E-disk table
 357:  190+10	E239  C3ACE3  		JP	IOINIT		; Set new I/O parameters
 358:  200+10	E23C  C349ED  		JP	SCSI		; SCSI direct driver
 359:				
 360:				;	*	*	*	*	*	*	*	*
 361:				;
 362:				;  Current system disk
 363:				;
 364:				;	*	*	*	*	*	*	*	*
 365:     -	E23F          		ORG	BIOS+03FH
 366:     -	E23F  00      	SYSDSK:	DEFB	0		; Assume A: for now
 367:					
 368:				; NOTE:   BIOS+040H thru BIOS+07FH modified by CONFIG
 369:				;	*	*	*	*	*	*	*	*
 370:				;
 371:				;  Initialization parameters for the CTC and DART/SIO
 372:				;
 373:				;  These values are set by the CONFIG program, and specify the
 374:				;  CTC and DART/SIO initialization parameters.  Each CTC channel
 375:				;  requires two bytes of initialization, while each DART/SIO 
 376:				;  channel may have up to 10 bytes of initialization information.
 377:				;
 378:				;	*	*	*	*	*	*	*	*
 379:     -	E240          		ORG	BIOS+040H
 380:     -	E240          	CTCVAL:	
 381:     -	E240  0303    	CTC0:	DEFB	03H,3		; ctc0 - SIO A channel baud rate (38.4K)
 382:     -	E242  470D    	CTC1:	DEFB	47H,13		; ctc1 - SIO B channel baud rate (9600)
 383:     -	E244  257D    	CTC2:	DEFB	25H,125		; ctc2 \ source of 1 second interrupt
 384:     -	E246  D57D    	CTC3:	DEFB	0D5H,125	; ctc3 / for NovaDOS real time clock
 385:				
 386:     -	E248          	SIOAVAL:			; DART/SIO channel A - terminal
 387:     -	E248  18      		DEFB	18H		; reset channel
 388:     -	E249  14      		DEFB	4 + 10H		; reset ext/status interrupts
 389:     -	E24A  44      	SIOAR4:	DEFB	01000100b	; x16 clock, 1 stop bit, no parity 	
 390:     -	E24B  03      		DEFB	3
 391:     -	E24C  C1      	SIOAR3:	DEFB	11000001b	; Rx 8 bits/char, Rx enabled
 392:     -	E24D  05      		DEFB	5
 393:     -	E24E  6A      	SIOAR5:	DEFB	01101010b	; HIBAUD, Tx 8 bits/char, TX enabled, RTS
 394:     -	E24F  11      		DEFB	1 + 10H		; reset ext/status interrupts
 395:     -	E250  1D      	SIOAR1:	DEFB	00011101b	; interrupt on all Rx chars (parity no effect)
 396:								; interrupt on status/external
 397:								; status affects vector
 398:     -	0009          	SIOALNG	EQU	$-SIOAVAL
 399:				
 400:     -	E251          	SIOBVAL:			; DART/SIO channel B - modem
 401:     -	E251  18      		DEFB	18H		; reset channel
 402:     -	E252  02      		DEFB	2
 403:     -	E253  00      	SIOBR2:	DEFB	SIOINT & 255	; interrupt vector table address
 404:     -	E254  14      		DEFB	4 + 10H		; reset ext/status interrupts
 405:     -	E255  44      	SIOBR4:	DEFB	01000100b	; x16 clock, 1 stop bit, no parity 	
 406:     -	E256  03      		DEFB	3
 407:     -	E257  C1      	SIOBR3:	DEFB	11000001b	; Rx 8 bits/char, Rx enabled
 408:     -	E258  05      		DEFB	5
 409:     -	E259  EA      	SIOBR5:	DEFB	11101010b	; FDCRST, Tx 8 bits/char, TX enabled, RTS
 410:     -	E25A  11      		DEFB	1 + 10H		; reset ext/status interrupts
 411:     -	E25B  1F      	SIOBR1:	DEFB	00011111b	; interrupt on all Rx chars (parity no effect)
 412:								; interrupt on transmitter buffer empty
 413:								; interrupt on status/external
 414:								; status affects vector
 415:     -	000B          	SIOBLNG	EQU	$-SIOBVAL
 416:				
 417:				;	*	*	*	*	*	*	*	*
 418:				;
 419:				;  Maximum drive letter available:
 420:				;
 421:				;  This value is installed by the CONFIG program, and is used by
 422:				;  the SELECT routine (optionally) to avoid selecting any disk 
 423:				;  units above the maximum letter.  This variable was previously
 424:				;  the NDSKS (# of floppy disks available) parameter in the 1.x
 425:				;  and 2.x bios.
 426:				;
 427:				;  Note: Although this parameter is set with the CONFIG utility,
 428:				;  it is ignored unless the MAX$DRIVE parameter is set to YES.
 429:				;
 430:				;	*	*	*	*	*	*	*	*
 431:     -	E25C          		ORG	BIOS+05CH
 432:     -	E25C          	MAX$DRV$LTR:
 433:     -	E25C  06      		DEFB	'G'-'A'		; Allow drives A-G
 434:				
 435:				;	*	*	*	*	*	*	*	*
 436:				;
 437:				;  Step rates for the four floppy drives.
 438:				;
 439:				;  These values are set by the CONFIG program.
 440:				;
 441:				;	*	*	*	*	*	*	*	*
 442:     -	E25D          		ORG	BIOS+05DH
 443:     -	E25D          	STPRAT:
 444:     -	E25D  03030303		DEFB	3,3,3,3		; Initial rates = 3ms
 445:				
 446:				;	*	*	*	*	*	*	*	*
 447:				;
 448:				;  Initial IOBYTE value
 449:				;
 450:				;  This value is set by the CONFIG program, and is used as the
 451:				;  initial value for the IOBYTE (location 0003H) on cold boot.
 452:				;
 453:				;  CP/M defines the following IOBYTE devices:
 454:				;
 455:				;  Bit: 76543210
 456:				;	      xx  Console (0=TTY:, 1=CRT:, 2=BAT:, 3=UC1:)
 457:				;	    xx	  Reader  (0=TTY:, 1=PTR:, 2=UR1:, 3=UR2:)
 458:				;	  xx	  Punch   (0=TTY:, 1=PTP:, 2=UP1:, 3=UP2:)
 459:				;	xx	  List    (0=TTY:, 1=CRT:, 2=LPT:, 3=UL1:)
 460:				;
 461:				;  In the AMPRO 3.0 bios, the devices are mapped to the serial
 462:				;  and parallel ports as follows:
 463:				;
 464:				;  CRT: Serial Port A		All other devices are undefined.
 465:				;  TTY:	Serial Port B		    UC1:  PTR:  UR1:  UR2:  
 466:				;  LPT: Parallel port		    UL1:  PTP:  UP1:  UP2:  
 467:				;
 468:				;	*	*	*	*	*	*	*	*
 469:     -	E261          		ORG	BIOS+061H
 470:     -	E261  81      	IOBYT:	DEFB	81H		; 10 00 00 01	Initial values:
 471:								; || || || ||
 472:								; || || ||  \= CON: Serial port A (CRT:)
 473:								; || ||  \==== RDR: Serial port B (TTY:)
 474:								; ||  \======= PUN: Serial port B (TTY:)
 475:								;  \========== LST: Parallel port (LPT:)
 476:				
 477:				;	*	*	*	*	*	*	*	*
 478:				;
 479:				;  AutoStart command
 480:				;
 481:				;  This value is set by the CONFIG program, and is used as the
 482:				;  initial command to ZCPR3.  This command is ignored in the CP/M
 483:				;  CCP.
 484:				;
 485:				;  The format of this region is:
 486:				;
 487:				;  Command length -- 1 byte
 488:				;  Command text   -- 8 bytes (max)
 489:				;  Trailing zero  -- 1 byte
 490:				;
 491:				;	*	*	*	*	*	*	*	*
 492:     -	E262          		ORG	BIOS+062H
 493:     -	E262          	AUTOCMD:
 494:     -	E262  08535441		DEFB	8,'STARTUP ',0	; Cmd length + cmd + 0 terminator
	              52545550
	              2000
 495:				
 496:     -	E26C          	AUTCMD$END	EQU	$
 497:				;	*	*	*	*	*	*	*	*
 498:				;
 499:				;  Handshake required flags for DART/SIO channels A and B
 500:				;
 501:				;  These values are set by the CONFIG program, and indicate if
 502:				;  hardware handshaking is required for each of the two serial
 503:				;  channels.  Bit zero (0) of each flag should be set to a one
 504:				;  to indicate hardware handshaking.
 505:				;
 506:				;	*	*	*	*	*	*	*	*
 507:     -	E26C          		ORG	BIOS+06CH
 508:     -	E26C  01      	HSA:	DEFB	1		; Handshake flag for channel A
 509:     -	E26D  01      	HSB:	DEFB	1		; Handshake flag for channel B
 510:     -	E26E  00      		DEFB	0		; (Reserved)
 511:     -	E26F  00      		DEFB	0		; (Reserved)
 512:				
 513:				;	*	*	*	*	*	*	*	*
 514:				;
 515:				;  Drive select bytes
 516:				;
 517:				;  These values are modified by the floppy drive select code, the
 518:				;  warm boot code, and several "E" utilities.  The format of each
 519:				;  select byte is as follows:
 520:				;
 521:				;		  Bit:	76543210
 522:				;       Speed select	x		0=normal,  1=double
 523:				;       Step select	 x		0=single,  1=double
 524:				;       Disk density	  x		0=double,  1=single
 525:				;       Side select	   x		0=Side 0,  1=Side 1
 526:				;       Drive unit 4	    x		.
 527:				;       Drive unit 3	     x		.  Select drive
 528:				;       Drive unit 2	      x		.  unit 1,2,3,4
 529:				;       Drive unit 1	       x	.
 530:				;		  Bit:  76543210
 531:				;
 532:				;	*	*	*	*	*	*	*	*
 533:     -	E270          		ORG	BIOS+070H
 534:     -	E270          	DRIVE$TYPES:
 535:     -	E270  01      		DEFB	01H		; Drive A:  DD, Unit 1
 536:     -	E271  02      		DEFB	02H		; Drive B:  DD, Unit 2
 537:     -	E272  04      		DEFB	04H		; Drive C:  DD, Unit 3
 538:     -	E273  08      		DEFB	08H		; Drive D:  DD, Unit 4
 539:     -	E274  02      		DEFB	02H		; Drive E:  DD, Unit 2
 540:     -	E275  000000  		DEFB	0,0,0		; (Reserved)
 541:				
 542:				;	*	*	*	*	*	*	*	*
 543:				;
 544:				;  Reserved data area
 545:				;
 546:				;	*	*	*	*	*	*	*	*
 547:     -	E278          		ORG	BIOS+078H
 548:     -	E278  00000000		DEFW	0,0,0,0
	              00000000
 549:				
 550:				;	*	*	*	*	*	*	*	*
 551:				;
 552:				;  Disk drive parameter headers
 553:				;
 554:				;  Physical drives A,B,C,D	Floppy drives
 555:				;
 556:				;  Physical drive  E		Special E-disk
 557:				;
 558:				;  Physical drives F,G		Hard disk drives
 559:				;
 560:				;	*	*	*	*	*	*	*	*
 561:     -	E280          		ORG	BIOS+080H
 562:     -	E280          	DPBASE:
 563:     -	E280  45E30000		DEFW	XLTSS,0,0,0,DIRBUF,SPARM,CSVA,ALVA	; BIOS+80H
	              00000000
	              F1F418E3
	              71F511F6
 564:     -	E290  45E30000		DEFW	XLTSS,0,0,0,DIRBUF,SPARM,CSVB,ALVB	; BIOS+90H
	              00000000
	              F1F418E3
	              B1F543F6
 565:     -	E2A0  45E30000		DEFW	XLTSS,0,0,0,DIRBUF,SPARM,CSVC,ALVC	; BIOS+A0H
	              00000000
	              F1F418E3
	              D1F575F6
 566:     -	E2B0  45E30000		DEFW	XLTSS,0,0,0,DIRBUF,SPARM,CSVD,ALVD	; BIOS+B0H
	              00000000
	              F1F418E3
	              D1F575F6
 567:     -	E2C0  6AE30000		DEFW	XLTE1,0,0,0,DIRBUF,EPARM,CSVE,ALVE	; BIOS+C0H
	              00000000
	              F1F45AE3
	              D1F575F6
 568:     -	E2D0  00000000		DEFW	0,0,0,0,DIRBUF,FPARM,CSVF,ALVF		; BIOS+D0H
	              00000000
	              F1F427ED
	              A7F6A7F6
 569:     -	E2E0  00000000		DEFW	0,0,0,0,DIRBUF,GPARM,CSVG,ALVG		; BIOS+E0H
	              00000000
	              F1F437ED
	              A7F6A7F6
 570:				;	DEFW 	0,0,0,0,DIRBUF,HPARM,CSVH,ALVH		; BIOS+F0H
 571:				;	DEFW 	0,0,0,0,DIRBUF,IPARM,CSVI,ALVI		; BIOS+100H
 572:				;	DEFW 	0,0,0,0,DIRBUF,JPARM,CSVJ,ALVJ		; BIOS+110H
 573:				;	DEFW 	0,0,0,0,DIRBUF,KPARM,CSVK,ALVK		; BIOS+120H
 574:				;	DEFW 	0,0,0,0,DIRBUF,LPARM,CSVL,ALVL		; BIOS+130H
 575:				;	DEFW 	0,0,0,0,DIRBUF,MPARM,CSVM,ALVM		; BIOS+140H
 576:				;	DEFW 	0,0,0,0,DIRBUF,NPARM,CSVN,ALVN		; BIOS+150H
 577:				;	DEFW 	0,0,0,0,DIRBUF,OPARM,CSVO,ALVO		; BIOS+160H
 578:				;	DEFW 	0,0,0,0,DIRBUF,PPARM,CSVP,ALVP		; BIOS+170H
 579:				;
 580:				;----------- END OF STUFF BETTER LEFT ALONE -----------------------
 581:				;
 582:     -	E2F0  00000000		DEFW	0,0,0,0,0,0,0,0
	              00000000
	              00000000
	              00000000
 583:     -	E300          	VECTORS:			; interrupt vectors, starting at BIOS+100H
 584:				
 585:     -	E300          	SIOINT:				; SIOINT lo address must be on even multiple
 586:								; of 16 (ie xxxx0000)	- BIOS + 100H
 587:     -	E300  77EC    		defw	mdmTxE		; Ch. B Tx buffer empty	- BIOS + 100H
 588:     -	E302  50EC    		defw	mdmsts		; Ch. B Ext/Status chng	- BIOS + 102H
 589:     -	E304  0BEC    		defw	mdmchk		; Ch. B RX char avail	- BIOS + 104H
 590:     -	E306  DEEB    		defw	mdmerr		; Ch. B Spcl Rx cond	- BIOS + 106H
 591:     -	E308  CDEC    		defw	ei$reti		; Ch. A Tx buffer empty	- BIOS + 108H
 592:     -	E30A  41EC    		defw	keysts		; Ch. A Ext/Status chng	- BIOS + 10AH
 593:     -	E30C  EFEB    		defw	KEYCHK		; Ch. A RX char avail	- BIOS + 10CH
 594:     -	E30E  CDEB    		defw	keyerr		; Ch. A Spcl Rx cond	- BIOS + 10EH
 595:				
 596:     -	E310          	CTCINT:				; CLCINT lo address must be on even multiple
 597:								; of 8 (ie xxxxx000)
 598:     -	E310  CDEC    		defw	ei$reti		; CTC0 int. not used	- BIOS + 110H
 599:     -	E312  CDEC    		defw	ei$reti		; CTC1 int. not used	- BIOS + 112H
 600:     -	E314  CDEC    		defw	ei$reti		; CTC2 int. not used	- BIOS + 114H
 601:     -	E316  9CEC    		defw	CLKCHK		; 1sec int from CTC3	- BIOS + 116H
 602:				;
 603:     -	E318          	SPARM:				; Ampro single sided 48tpi
 604:     -	E318  2800    		DEFW	40		; Sectors/track
 605:     -	E31A  04      		DEFB	4		; Block shift
 606:     -	E31B  0F      		DEFB	15		; Block mask
 607:     -	E31C  01      		DEFB	1		; Extent mask
 608:     -	E31D  5E00    		DEFW	94		; Disk size -1
 609:     -	E31F  3F00    		DEFW	63		; Directory max
 610:     -	E321  80      		DEFB	128		; Allocation 0
 611:     -	E322  00      		DEFB	0		; Allocation 1
 612:     -	E323  1000    		DEFW	16		; Check size
 613:     -	E325  0200    		DEFW	2		; Offset       
 614:				
 615:     -	E327          	DPARM:				; Ampro double sided 48tpi
 616:								; -or-  single sided 96tpi
 617:     -	E327  2800    		DEFW	40		; Sectors/track
 618:     -	E329  04      		DEFB	4		; Block shift  
 619:     -	E32A  0F      		DEFB	15		; Block mask  
 620:     -	E32B  01      		DEFB	1		; Extent mask  
 621:     -	E32C  C200    		DEFW	194		; Disk size -1 
 622:     -	E32E  7F00    		DEFW	127		; Directory max
 623:     -	E330  C0      		DEFB	192		; Allocation 0 
 624:     -	E331  00      		DEFB	0		; Allocation 1 
 625:     -	E332  2000    		DEFW	32		; Check size   
 626:     -	E334  0200    		DEFW	2		; Offset       
 627:				
 628:     -	E336          	QPARM:				; Ampro double sided 96tpi
 629:     -	E336  2800    		DEFW	40		; Sectors/track
 630:     -	E338  04      		DEFB	4		; Block shift  
 631:     -	E339  0F      		DEFB	15		; Block mask  
 632:     -	E33A  00      		DEFB	0		; Extent mask  
 633:     -	E33B  8A01    		DEFW	394		; Disk size -1 
 634:     -	E33D  FF00    		DEFW	255		; Directory max
 635:     -	E33F  F0      		DEFB	240		; Allocation 0 
 636:     -	E340  00      		DEFB	0		; Allocation 1 
 637:     -	E341  4000    		DEFW	64		; Check size   
 638:     -	E343  0200    		DEFW	2		; Offset       
 639:				
 640:     -	E345          	XLTSS:				; Single sided format skew table
 641:     -	E345  01020304		DEFB	1,2,3,4,5,6,7,8,9,10
	              05060708
	              090A
 642:				
 643:     -	E34F          	XLTDS:				; Double sided format skew table
 644:     -	E34F  11121314		DEFB	17,18,19,20,21,22,23,24,25,26
	              15161718
	              191A
 645:				
 646:				
 647:				;	*	*	*	*	*	*	*	*
 648:				;
 649:				;  Special user-defined drive		"E-disk"
 650:				;
 651:				;  NOTE: The order of the following table must not be changed,
 652:				;	 since many existing utilities depend on this order.
 653:				;
 654:				;  A call to the BIOS function GETEDISK (BIOS+030H) returns the
 655:				;  address of EPARM.  The type table entry is defined as the re-
 656:				;  turned value -1, and the translate table value as the returned
 657:				;  value +15.  The translate table has space for 20 entries in
 658:				;  bios version 1 or 2, 26 entries in bios version 3+.
 659:				;
 660:				;	*	*	*	*	*	*	*	*
 661:     -	E359  82      	ETYPE:	DEFB	82H		; ETYPE must be at EPARM - 1
 662:     -	E35A          	EPARM:				; Set for:	KAYPRO 
 663:     -	E35A  2800    		DEFW	40		; SEC/TRK   	KAYPRO IS 40
 664:     -	E35C  03      		DEFB	3		; BLOCK SHIFT
 665:     -	E35D  07      		DEFB	7		; BLOCK MASK
 666:     -	E35E  00      		DEFB	0		; EXTENT MASK
 667:     -	E35F  C200    		DEFW	194		; DISK SIZE -1 	KAYPRO IS 194
 668:     -	E361  3F00    		DEFW	63		; DIRECTORY MAX -1
 669:     -	E363  F0      		DEFB	240		; ALLOC 0 	KAYPRO 240
 670:     -	E364  00      		DEFB	0		; ALLOC 1
 671:     -	E365  1000    		DEFW	16		; CHECK SIZE
 672:     -	E367  0100    		DEFW	1		; OFFSET 	KAYPRO IS 1
 673:				
 674:     -	E369          	EDSD:
 675:     -	E369  01      		DEFB	1		; DEFAULT DRIVE B:
 676:				
 677:     -	E36A          	XLTE1:				; TRANSLATE TABLE FOR E DISK
 678:     -	E36A  00010203		DEFB	0,1,2,3,4,5,6,7,8,9
	              04050607
	              0809
 679:				
 680:     -	E374  00000000		DEFW	0,0,0,0,0,0,0,0	; 26 entries max in XLT1
	              00000000
	              00000000
	              00000000
 681:				
 682:				
 683:				
 684:				
 685:				;  End of E-disk user defined table
 686:				;	*	*	*	*	*	*	*	*
 687:				;
 688:				;  GETTBL	GET NEXT JUMP TABLE ADDRESS
 689:				;
 690:				;  While this routine returns the address of NXTTBL, it can also
 691:				;  be used to identify the BIOS version level.
 692:				;
 693:				;  For pre-2.0 systems, the A register is returned unchanged,
 694:				;  and the HL register pair returned 0FFFFH.
 695:				;
 696:				;  For 2.0 and higher, HL returns the address of NXTTBL (never
 697:				;  equal to 0FFFFH), and A contains the assembly version of this
 698:				;  bios code.
 699:				;
 700:				;	*	*	*	*	*	*	*	*
 701:     -	E384          	GETTBL:
 702:  210+10	E384  218AE3  		LD	HL,NXTTBL	; Get address of jump table
 703:  220+7	E387  3E2B    		LD	A,VERS		; .  and version number
 704:     -	E389          	NXTJMP:				; Label for dummy routines
 705:  227+10	E389  C9      		RET
 706:				
 707:     -	E38A          	NXTTBL:
 708:  237+10	E38A  C3D4E3  		JP	SWAP		; +00H Swap two logical drives
 709:  247+10	E38D  C3EAE3  		JP	HD$INFO		; +03H Get HD table information
 710:  257+10	E390  C3FAE3  		JP	PHTBAC		; +06H Get/set PhyTab access
 711:  267+10	E393  C305E4  		JP	PAGET		; +09H Get PhyTab entry address
 712:  277+10	E396  C3D0EC  		JP	TOD		; +0CH Get/set system time
 713:  287+10	E399  C3FEEA  		jp	TTYIST		; +0FH modem input status
 714:  297+10	E39C  C3F5EA  		jp	TTYOST		; +12H modem output status
 715:  307+10	E39F  C35BEB  		jp	TTYBRK		; +15H send 300mS break to modem
 716:  317+10	E3A2  C35CEA  		jp	CONPEEK		; +18H console input peek
 717:  327+10	E3A5  C389E3  		JP	NXTJMP		; +1BH RESERVED ENTRY
 718:				
 719:				;	*	*	*	*	*	*	*	*
 720:				;
 721:				;  GETEDSK	Get E-disk pointer
 722:				;
 723:				;	*	*	*	*	*	*	*	*
 724:     -	E3A8          	GETEDSK:
 725:  337+10	E3A8  215AE3  		LD	HL,EPARM
 726:  347+10	E3AB  C9      		RET
 727:				
 728:				;	*	*	*	*	*	*	*	*
 729:				;
 730:				;  IOINIT
 731:				;
 732:				;  Initialize the CTC and DART comm devices according to the
 733:				;  information provided at BIOS + 40 hex.
 734:				;
 735:				;  Entry from BOOT and also via the JMP IOINIT from the BIOS jump
 736:				;  table.
 737:				;
 738:				;	*	*	*	*	*	*	*	*
 739:     -	E3AC          	IOINIT:
 740:  357+4	E3AC  F3      		di
 741:  361+7	E3AD  3E10    		ld	a,CTCINT & 0FFH	; NOTE: CTCINT address low byte must
 742:								; be of form xxxxx000
 743:  368+11	E3AF  D340    		out	(CTCA0),a	; initialize ctc interrupts
 744:  379+10	E3B1  2140E2  		LD	HL,CTCVAL
 745:  389+10	E3B4  014002  		LD	BC,2*256+CTCA0	; Initialize CTC0
 746:  399+16+5	E3B7  EDB3    		OTIR
 747:  415+10	E3B9  015002  		LD	BC,2*256+CTCA1	; Initialize CTC1
 748:  425+16+5	E3BC  EDB3    		OTIR
 749:  441+10	E3BE  016002  		LD	BC,2*256+CTCA2	; Initialize CTC2
 750:  451+16+5	E3C1  EDB3    		OTIR
 751:  467+10	E3C3  017002  		LD	BC,2*256+CTCA3	; Initialize CTC3
 752:  477+16+5	E3C6  EDB3    		OTIR
 753:  493+10	E3C8  018409  		LD	BC,SIOALNG*256+SIOCPA; Initialize DART channel A
 754:  503+16+5	E3CB  EDB3    		OTIR
 755:  519+10	E3CD  018C0B  		LD	BC,SIOBLNG*256+SIOCPB; Initialize DART channel B
 756:  529+16+5	E3D0  EDB3    		OTIR
 757:  545+4	E3D2  FB      		ei
 758:  549+10	E3D3  C9      		RET
 759:				
 760:				;	*	*	*	*	*	*	*	*
 761:				;
 762:				;  SWAP		Swap logical drives
 763:				;
 764:				;  Entry here causes the two LOGICAL drives identified in B and C
 765:				;  to be swapped in position.  This alters the current LOGICAL
 766:				;  name of the target drive for all subsequent disk operations.
 767:				;
 768:				;  For example, assume the CP/M logical drive A: is the left
 769:				;  floppy disk drive, and the CP/M logical drive F: is the first
 770:				;  hard disk partition.  If on entry to the SWAP routine the B
 771:				;  register contained 0 (logical drive A:) and the C register
 772:				;  contained 5 (logical drive F:), after SWAP, all accesses to
 773:				;  CP/M drive A: will be to the first hard disk partition, while
 774:				;  all accesses to CP/M drive F: would be to the left floppy 
 775:				;  drive.
 776:				;
 777:				;  		* * * * *   WARNING   * * * * * 
 778:				;
 779:				;  To maintain compatibility with all utilities, and also for
 780:				;  some special case coding within this BIOS, the user definable
 781:				;  E-DISK must remain as Drive E logical.
 782:				;
 783:				;	*	*	*	*	*	*	*	*
 784:     -	E3D4          	SWAP:
 785:  559+4	E3D4  78      		LD	A,B		; Get first drive logical #
 786:  563+17	E3D5  CD05E4  		CALL	PAGET		; Compute current address in table
 787:  580+11	E3D8  E5      		PUSH	HL		; Save this address
 788:  591+4	E3D9  79      		LD	A,C		; Get second drive logical #
 789:  595+17	E3DA  CD05E4  		CALL	PAGET		; Compute current address in table
 790:  612+10	E3DD  D1      		POP	DE		; Get pointer to first back in D
 791:  622+7	E3DE  0604    		LD	B,4		; Set up to move 4 bytes
 792:     -	E3E0          	PATMV:
 793:  629+7	E3E0  4E      		LD	C,(HL)		; Get a byte from the first str
 794:  636+7	E3E1  1A      		LD	A,(DE)		; Get a byte from the second str
 795:  643+7	E3E2  77      		LD	(HL),A		; Swap the bytes
 796:  650+4	E3E3  79      		LD	A,C		; .
 797:  654+7	E3E4  12      		LD	(DE),A		; .
 798:  661+6	E3E5  13      		INC	DE		; Bump pointers
 799:  667+6	E3E6  23      		INC	HL		; .
 800:  673+8+5	E3E7  10F7    		DJNZ	PATMV
 801:  681+10	E3E9  C9      		RET			; No -- all done
 802:				
 803:				;	*	*	*	*	*	*	*	*
 804:				;
 805:				;  HD$INFO	Return HD information.
 806:				;
 807:				;  Returns a pointer to various HD pointers.
 808:				;
 809:				;	*	*	*	*	*	*	*	*
 810:     -	E3EA          	HD$INFO:
 811:  691+10	E3EA  21EEE3  		LD	HL,HD$ALV$AVAIL	; Get pointer to available area
 812:  701+10	E3ED  C9      		RET			; Provide addr if ptr zero
 813:				
 814:     -	E3EE          	HD$ALV$AVAIL:
 815:     -	E3EE  A7F6    		DEFW	HD$CURRENT	; Current BIOS buffer area value
 816:     -	E3F0  A7F6    		DEFW	HD$VECTORS	; Hard disk allocation vector base
 817:     -	E3F2  48ED    		DEFW	HD$BYTE$BLOCK	; Location of SCSI byte/block flag
 818:     -	E3F4  0000    		DEFW	0		; Reserved
 819:     -	E3F6  0000    		DEFW	0		; Reserved
 820:     -	E3F8  0000    		DEFW	0		; Reserved
 821:				
 822:				;	*	*	*	*	*	*	*	*
 823:				;
 824:				;  PHTBAC	PHYSICAL TABLE ACCESS
 825:				;
 826:				;  On entry, if the HL register pair is 0000H, the address of the
 827:				;  Logical vs Physical table is returned in HL, with the length 
 828:				;  of that table in the A register.
 829:				;
 830:				;  If on entry, the HL register pair is non-zero, the current
 831:				;  table is replaced with the user data starting at the location
 832:				;  pointed to by HL for the length of the table.
 833:				;
 834:				;  Note:  When updating the table, ALL bytes are re-written. No
 835:				;  length parameter is accepted from the user, and no alternate
 836:				;  starting address is recognized.
 837:				;
 838:				;  Refer to the PHYTAB for byte definitions...
 839:				;
 840:				;	*	*	*	*	*	*	*	*
 841:     -	E3FA          	PHTBAC:
 842:  711+4	E3FA  EB      		EX	DE,HL		; Save ptr in case we need it
 843:  715+4	E3FB  7A      		LD	A,D		; Test former HL
 844:  719+4	E3FC  B3      		OR	E		; 
 845:  723+7	E3FD  3E50    		LD	A,PHYEND-PHYTAB	; Get length of table
 846:  730+10	E3FF  2116E4  		LD	HL,PHYTAB	; .  and address, too.
 847:  740+7+5	E402  200B    		JR	NZ,CPY$TBL	; Copy new table if ptr non-zero
 848:  747+10	E404  C9      		RET			; Provide addr if ptr zero
 849:				
 850:				;	*	*	*	*	*	*	*	*
 851:				;
 852:				;  PAGET	GET DRIVE LOGICAL INFORMATION
 853:				;
 854:				;  Entry here from within the BIOS, as well as from the NXTTBL
 855:				;  BIOS Jump entry.
 856:				;
 857:				;  Enter with the Drive Logical address in the A reg.
 858:				;
 859:				;  Exits with the Logical Table entry address in the HL reg pair.
 860:				;
 861:				;  NOTE: Destroys DE and A
 862:				;
 863:				;	*	*	*	*	*	*	*	*
 864:     -	E405          	PAGET:
 865:  757+10	E405  2116E4  		LD	HL,PHYTAB	; Get base of physical table
 866:  767+4	E408  87      		ADD	A,A		; Compute offset to the descriptor
 867:  771+4	E409  87      		ADD	A,A		; .
 868:  775+4	E40A  5F      		LD	E,A		; .
 869:  779+7	E40B  1600    		LD	D,0		; .
 870:  786+11	E40D  19      		ADD	HL,DE		; .
 871:  797+10	E40E  C9      		RET			; Return with ptr in HL
 872:				
 873:     -	E40F          	CPY$TBL:			; Copy from DE to HL, length A
 874:  807+4	E40F  EB      		EX	DE,HL		; .  (exchange DE and HL)
 875:  811+4	E410  4F      		LD	C,A		; .  (put length info in BC)
 876:  815+7	E411  0600    		LD	B,0		; .  (now it's a-ok for LDIR)
 877:  822+16+5	E413  EDB0    		LDIR			; .  (use LDIR to move table)
 878:  838+10	E415  C9      		RET			; and return to caller
 879:				
 880:				;	*	*	*	*	*	*	*	*
 881:				;
 882:				;  PHYSICAL DRIVER TABLE
 883:				;
 884:				;  This table contains information to identify the Logical vs
 885:				;  Physical drives requested, and also the disk driver required 
 886:				;  for the particular drive.
 887:				;
 888:				;  The table is built as 16 groups of 4-bytes each, arranged in
 889:				;  the logical order of drives A thru G for a total of 28 bytes.
 890:				;
 891:				;  The four bytes defining each Logical drive are as follows:
 892:				;
 893:				;  +0	Disk Driver ID number, 0=reserved for error, Max=7
 894:				;
 895:				;  +1	Physical offset from DPBASE in DPH table, and the drive
 896:				;	unit number.
 897:				;
 898:				;	Bits   7654:	Offset to DPBASE 0 - F
 899:				;
 900:				;	Bits   3210:	Physical device address to be passed
 901:				;			to the respective driver.
 902:				;
 903:				;			For floppies, this is the drive unit #.
 904:				;			For hard disks, these are reserved.
 905:				;
 906:				;  +2	Type identifier for this drive 
 907:				;
 908:				;	Floppy usage:
 909:				;
 910:				;		   Bit: 76543210
 911:				;	Density		x	   0=single     1=double
 912:				;	Sides		 x	   0=single     1=double
 913:				;	Sector #'s	  x	   0=same       1=continuous
 914:				;	Track count	   x	   0=down       1=down front, up back
 915:				;	Alloc unit	    xx	   00=1K   01=2K   10=4K   11=8K
 916:				;	Sector size	      xx   00=128  01=256  10=512  11=1024
 917:				;		   Bit: 76543210
 918:				;
 919:				;	Hard disk usage:
 920:				;
 921:				;		   Bit: 76543210
 922:				;	LUN		xxx	   Logical unit number (0-7)
 923:				;	Reserved	   x	   
 924:				;	Alloc unit	    xx	   00=1K   01=2K   10=4K   11=8K
 925:				;	Sector size	      xx   00=128  01=256  10=512  11=1024
 926:				;		   Bit: 76543210
 927:				;
 928:				;	Note:	Allocation unit and sector size usage are the same
 929:				;		for floppy and hard disk.
 930:				;
 931:				;
 932:				;  +3	00 for floppy or SCSI bus address for hard disk.
 933:				;
 934:				;	For normal SCSI operations, only one bit may be set.
 935:				;
 936:				;		   Bit: 76543210
 937:				;	SCSI address 0	       x	This is the actual
 938:				;	SCSI address 1	      x		bit pattern supplied
 939:				;	SCSI address 2	     x		during the SCSI
 940:				;	SCSI address 3	    x		select routine.  No
 941:				;	SCSI address 4	   x		internal address
 942:				;	SCSI address 5	  x		translation or bit
 943:				;	SCSI address 6	 x		scaling is done.
 944:				;	SCSI address 7	x		
 945:				;
 946:				;  +4	Duplicated for drives B thru P
 947:				; thru
 948:				; +63
 949:				;
 950:				;  Disk Driver Linkage  +64 thru +79
 951:				;
 952:				;  Each disk driver is described by 2 bytes which point to the
 953:				;  driver to be used, with driver 0 reserved for the SELECT ERROR
 954:				;  trap for unused or deselected drive letters.
 955:				;
 956:				;	*	*	*	*	*	*	*	*
 957:     -	E416          	PHYTAB:
 958:     -	E416  01008600		DEFB	1,000H, SSDD48, 0H	; Floppy drive A
 959:     -	E41A  01118600		DEFB	1,011H, SSDD48, 0H	; Floppy drive B
 960:     -	E41E  01228600		DEFB	1,022H, SSDD48, 0H	; Floppy drive C
 961:     -	E422  01338600		DEFB	1,033H, SSDD48, 0H	; Floppy drive D
 962:				
 963:     -	E426  024400FF		DEFB	2,044H, 0H, 0FFH ; Special floppy drive E
 964:				
 965:     -	E42A  00500000		DEFB	0,050H,0,0		; Hard disk drive F
 966:     -	E42E  00600000		DEFB	0,060H,0,0		; Hard disk drive G
 967:     -	E432  00700000		DEFB	0,070H,0,0		; Hard disk drive H
 968:     -	E436  00800000		DEFB	0,080H,0,0 		; Hard disk drive I
 969:				
 970:     -	E43A  00900000		DEFB	0,090H,0,0		; Hard disk drive J
 971:     -	E43E  00A00000		DEFB	0,0A0H,0,0		; Hard disk drive K
 972:     -	E442  00B00000		DEFB	0,0B0H,0,0		; Hard disk drive L
 973:     -	E446  00C00000		DEFB	0,0C0H,0,0		; Hard disk drive M
 974:				
 975:     -	E44A  00D00000		DEFB	0,0D0H,0,0		; Hard disk drive N
 976:     -	E44E  00E00000		DEFB	0,0E0H,0,0		; Hard disk drive O
 977:     -	E452  00F00000		DEFB	0,0F0H,0,0		; Hard disk drive P
 978:				
 979:     -	E456          	DRVRADR:			; Driver table
 980:     -	E456  E1E4    		DEFW	SELERR		; Driver 0 - select error
 981:     -	E458  E5E7    		DEFW	FLOPPY		; Driver 1 - floppy
 982:     -	E45A  E5E4    		DEFW	DISKE		; Driver 2 - E-disk
 983:     -	E45C  6BED    		DEFW	DRVR3		; Driver 3 - SCSI hard disk
 984:     -	E45E  E1E4    		DEFW	SELERR		; Driver 4 - not defined
 985:     -	E460  E1E4    		DEFW	SELERR		; Driver 5 - not defined
 986:     -	E462  E1E4    		DEFW	SELERR		; Driver 6 - not defined
 987:     -	E464  E1E4    		DEFW	SELERR		; Driver 7 - not defined
 988:				
 989:     -	E466          	PHYEND	EQU	$
 990:				;	*	*	*	*	*	*	*	*
 991:				;
 992:				;  HOME		Home the selected disk
 993:				;
 994:				;  Entry via the bios jump table HOME
 995:				;
 996:				;	*	*	*	*	*	*	*	*
 997:     -	E466          	HOME:
 998:  848+10	E466  010000  		LD	BC,0		; Set the current track to zero
 999:  858+17	E469  CD76E4  		CALL	SETTRK		; .
1000:  875+13	E46C  3A1AEF  		LD	A,(HSTWRT)	; Check for pending write
1001:  888+4	E46F  B7      		OR	A		; .
1002:  892+7+5	E470  2003    		JR	NZ,HOMED	; Pending write, leave active alone
1003:  899+13	E472  3219EF  		LD	(HSTACT),A	; No writes, clear host active
1004:     -	E475          	HOMED:
1005:  912+10	E475  C9      		RET
1006:				
1007:				;	*	*	*	*	*	*	*	*
1008:				;
1009:				;  SETTRK	Set track (BIOS JMP table entry)
1010:				;
1011:				;	*	*	*	*	*	*	*	*
1012:     -	E476          	SETTRK:				; Set track given by BC
1013:  922+20	E476  ED430DEF		LD	(SEKTRK),BC
1014:  942+20	E47A  ED4315EF		LD	(CPMTRK),BC
1015:  962+10	E47E  C9      		RET
1016:				
1017:				;	*	*	*	*	*	*	*	*
1018:				;
1019:				;  SETSEC	Set sector (BIOS JMP table entry)
1020:				;
1021:				;	*	*	*	*	*	*	*	*
1022:     -	E47F          	SETSEC:				; Set sector given by reg C
1023:  972+4	E47F  79      		LD	A,C
1024:  976+13	E480  320FEF  		LD	(SEKSEC),A
1025:  989+13	E483  3217EF  		LD	(CPMSEC),A
1026: 1002+10	E486  C9      		RET
1027:				
1028:				;	*	*	*	*	*	*	*	*
1029:				;
1030:				;  SETDMA	Set DMA (BIOS JMP table entry)
1031:				;
1032:				;	*	*	*	*	*	*	*	*
1033:     -	E487          	SETDMA:				; Set DMA address given by BC
1034: 1012+20	E487  ED4328EF		LD	(DMAADR),BC
1035: 1032+4	E48B  AF      		XOR	A		; clear flags for ZRDOS
1036: 1036+10	E48C  C9      		RET
1037:				
1038:				;	*	*	*	*	*	*	*	*
1039:				;
1040:				;  SECTRAN	Sector translation (BIOS JMP table entry)
1041:				;
1042:				;  NOTE: No sector translation is done for the AMPRO disk formats.
1043:				;
1044:				;	*	*	*	*	*	*	*	*
1045:     -	E48D          	SECTRAN:			; Translate sector number in BC
1046: 1046+4	E48D  60      		LD	H,B
1047: 1050+4	E48E  69      		LD	L,C
1048: 1054+10	E48F  C9      		RET
1049:				
1050:				;	*	*	*	*	*	*	*	*
1051:				;
1052:				;  SELECT	Select disk routine
1053:				;
1054:				;  Entry via the BIOS Jump Table SELDSK
1055:				;
1056:				;  Entry:
1057:				;	C  CP/M Logical drive
1058:				;	E  Bit zero is non-zero if this is the first select of the
1059:				;	   drive since warm or cold boot.
1060:				;
1061:				;	*	*	*	*	*	*	*	*
1062:     -	E490          	SELDSK:
1063: 1064+4	E490  79      		LD	A,C		; Get logical disk requested
1064: 1068+13	E491  3230F3  		LD	(LOGDSK),A	; Save it
1065: 1081+13	E494  320CEF  		LD	(SEKDSK),A	; .
1066:				
1067: 1094+13	E497  3A5CE2  		LD	A,(MAX$DRV$LTR)	; .  Is the letter requested
1068: 1107+4	E49A  B9      		CP	C		; .  greater than the max letter?
1069: 1111+7+5	E49B  3844    		JR	C,SELERR	; .  Yes -- return w/select error
1070:				
1071: 1118+20	E49D  ED7311ED		LD	(OLDSTK),SP	; save old stack
1072: 1138+10	E4A1  310FED  		LD	SP,LOCSTK	; set local stack
1073: 1148+7	E4A4  3EFF    		LD	A,0FFH		; No to either -- set SELECT cmd
1074:				
1075:				; NOTE:  we fall through to PDRVR
1076:				;	*	*	*	*	*	*	*	*
1077:				;
1078:				;  PDRVR	Physical driver linkage
1079:				;
1080:				;  Enter with the Logical Disk Drive saved at (LOGDSK) and the 
1081:				;  Physical Command in the A reg as:
1082:				;
1083:				;	FF	Select Disk Routine
1084:				;	00	Write Disk
1085:				;	01 	Read  Disk
1086:				;
1087:				;  The proper driver is computed and jumped to as needed.
1088:				;
1089:				;	*	*	*	*	*	*	*	*
1090:     -	E4A6          	PDRVR:
1091: 1155+11	E4A6  D5      		PUSH	DE		; Protect first select status
1092: 1166+13	E4A7  3235F3  		LD	(PHYCMD),A	; Save cmd for later
1093: 1179+13	E4AA  3A30F3  		LD	A,(LOGDSK)	; Get logical drive requested
1094: 1192+17	E4AD  CD05E4  		CALL	PAGET		; Get table address for this drive
1095: 1209+16	E4B0  2233F3  		LD	(PHYTAG),HL	; Save index to logical descriptor
1096: 1225+11	E4B3  E5      		PUSH	HL		; Save start address
1097: 1236+10	E4B4  1136F3  		LD	DE,TAGDRV	; Move the four tag bytes
1098: 1246+10	E4B7  010400  		LD	BC,4		; .
1099: 1256+16+5	E4BA  EDB0    		LDIR			; (LDIR)
1100: 1272+10	E4BC  E1      		POP	HL		; Restore starting address
1101: 1282+10	E4BD  D1      		POP	DE		; Restore first select status
1102: 1292+7	E4BE  7E      		LD	A,(HL)		; Get driver number
1103: 1299+4	E4BF  B7      		OR	A		; .  If zero, then select error
1104: 1303+7+5	E4C0  281F    		JR	Z,SELERR	; .
1105: 1310+4	E4C2  47      		LD	B,A		; save drive index
1106: 1314+6	E4C3  23      		INC	HL		; Bump to next position
1107: 1320+7	E4C4  7E      		LD	A,(HL)		; Get unit # and DPH offset
1108: 1327+7	E4C5  E60F    		AND	0FH		; Mask all but unit #
1109: 1334+13	E4C7  3231F3  		LD	(PHYDRV),A	; Save unit #
1110: 1347+7	E4CA  7E      		LD	A,(HL)		; Get unit # and DPH offset again
1111: 1354+7	E4CB  E6F0    		AND	0F0H		; Mask all but DPH offset
1112: 1361+13	E4CD  3232F3  		LD	(DPHDRV),A	; Save DPH offset
1113:     -	E4D0          	PDRVR1:	
1114: 1374+4	E4D0  78      		LD	A,B		; get driver number back
1115: 1378+4	E4D1  87      		ADD	A,A		; .
1116: 1382+4	E4D2  4F      		LD	C,A		; Compute ptr within driver table
1117: 1386+7	E4D3  0600    		LD	B,0		; .
1118: 1393+10	E4D5  2156E4  		LD	HL,DRVRADR	; .
1119: 1403+11	E4D8  09      		ADD	HL,BC		; .
1120: 1414+7	E4D9  7E      		LD	A,(HL)		; Get ptr to driver in HL
1121: 1421+6	E4DA  23      		INC	HL		; .
1122: 1427+7	E4DB  66      		LD	H,(HL)		; .
1123: 1434+4	E4DC  6F      		LD	L,A		; .
1124: 1438+13	E4DD  3A35F3  		LD	A,(PHYCMD)	; Get cmd back in the A reg
1125: 1451+4	E4E0  E9      		JP	(HL)		; Jump to the proper driver
1126:				
1127:				;	*	*	*	*	*	*	*	*
1128:				;
1129:				;  SELERR	Indicate select error to the BDOS
1130:				;
1131:				;	*	*	*	*	*	*	*	*
1132:     -	E4E1          	SELERR:
1133: 1455+10	E4E1  210000  		LD	HL,0		; Zero indicates select failed
1134: 1465+10	E4E4  C9      		RET
1135:				
1136:				;	*	*	*	*	*	*	*	*
1137:				;
1138:				;  DISKE	E-disk dispatcher -- driver code (02)
1139:				;
1140:				;  Enter with the operation code in the A register as:
1141:				;
1142:				;	FF	Select Disk
1143:				;	00	Write Disk
1144:				;	01	Read Disk
1145:				;
1146:				;	*	*	*	*	*	*	*	*
1147:     -	E4E5          	DISKE:
1148: 1475+11	E4E5  F5      		PUSH	AF		; Save command
1149: 1486+11	E4E6  D5      		PUSH	DE		; .  and first-select status
1150: 1497+13	E4E7  3A69E3  		LD	A,(EDSD)	; Get E-disk unit
1151: 1510+4	E4EA  5F      		LD	E,A		; Get type byte for the drive
1152: 1514+7	E4EB  1600    		LD	D,0		; .  we want to be the 'E'
1153: 1521+10	E4ED  2170E2  		LD	HL,DRIVE$TYPES	; .  disk
1154: 1531+11	E4F0  19      		ADD	HL,DE		; .
1155: 1542+7	E4F1  7E      		LD	A,(HL)		; .
1156: 1549+7	E4F2  E60F    		AND	00FH		; Strip all but select bit
1157: 1556+4	E4F4  47      		LD	B,A		; Save select bit
1158: 1560+10	E4F5  2174E2  		LD	HL,DRIVE$TYPES+4 ; Point to the E-disk drive byte
1159: 1570+7	E4F8  7E      		LD	A,(HL)		; Get the E-disk drive byte
1160: 1577+7	E4F9  E6F0    		AND	0F0H		; Strip select bits
1161: 1584+4	E4FB  B0      		OR	B		; OR in proper select bits
1162: 1588+7	E4FC  77      		LD	(HL),A		; Save new E-disk drive byte
1163: 1595+11	E4FD  E5      		PUSH	HL		; Save pointer to E-disk drive byte
1164: 1606+13	E4FE  3A59E3  		LD	A,(EPARM-1)	; Get type byte
1165: 1619+16	E501  2A33F3  		LD	HL,(PHYTAG)	; Save as PHYTAB type byte
1166: 1635+6	E504  23      		INC	HL		; .
1167: 1641+6	E505  23      		INC	HL		; .
1168: 1647+7	E506  77      		LD	(HL),A		; .
1169: 1654+13	E507  3238F3  		LD	(TAGTYP),A	; and as current type byte
1170: 1667+10	E50A  E1      		POP	HL		; Get E-disk drive byte ptr back
1171: 1677+15	E50B  CBAE    		RES	5,(HL)		; Indicate double density
1172: 1692+4	E50D  07      		RLCA			; See if E-disk is single density
1173: 1696+7+5	E50E  3802    		JR	C,E$IS$DD	; No,  leave bit alone
1174: 1703+15	E510  CBEE    		SET	5,(HL)		; Yes, indicate single density
1175:     -	E512          	E$IS$DD:
1176: 1718+10	E512  D1      		POP	DE		; Recover first select status
1177: 1728+10	E513  F1      		POP	AF		; .  and command
1178: 1738+4	E514  3C      		INC	A		; Select?
1179: 1742+10	E515  CA67E6  		JP	Z,SELEDSK	; Yes, perform select
1180: 1752+10	E518  C3E9E7  		JP	FLOPPYIO	; Otherwise use R/W floppy host
1181:				
1182:     -	E51B          	PUTS:				; Send zero-terminated str to con:
1183: 1762+7	E51B  7E      		LD	A,(HL)		; Get char
1184: 1769+6	E51C  23      		INC	HL		; Bump pointer
1185: 1775+4	E51D  B7      		OR	A		; Zero is end-of-string
1186: 1779+5+6	E51E  C8      		RET	Z		; Yes -- return
1187: 1784+4	E51F  4F      		LD	C,A		; Otherwise move to C register
1188: 1788+17	E520  CDA8EA  		CALL	CONOUT1		; .  and send to console
1189: 1805+12	E523  18F6    		JR	PUTS		; Repeat for remaining bytes
1190:				
1191:				;	*	*	*	*	*	*	*	*
1192:				;
1193:				;  WBOOT	Warm boot system
1194:				;
1195:				;  This routine reloads the CCP and BDOS from the current logical
1196:				;  disk defined as SYSDSK.  While SYSDSK is normally logical drive
1197:				;  A:, any other drive may be referenced by setting SYSDSK to the
1198:				;  desired logical drive address (0-15).
1199:				;
1200:				;  The warm boot consists of reading 1600 hex bytes of code, from
1201:				;  CP/M track 0, sector 1, for 44 CP/M records.  The code is loaded
1202:				;  starting with the CCP address, which is defined at the start of
1203:				;  this BIOS listing.
1204:				;
1205:				;  The disk currently assigned to SYSDSK must have a standard AMPRO
1206:				;  system image residing on the boot tracks (tracks 0 and 1).
1207:				;
1208:				;  If SYSDSK is not logical drive A:, the BDOS will still access the
1209:				;  current logical drive A: after the GOCPM entry in order to build
1210:				;  the directory allocation vector table for drive A: prior to the
1211:				;  selection of the current disk.
1212:				; 	
1213:				;	*	*	*	*	*	*	*	*
1214:     -	E525          	WBOOT:
1215: 1817+10	E525  318000  		LD	SP,80H		; Set stack to below default DMA
1216: 1827+13	E528  3A3FE2  		LD	A,(SYSDSK)	; Get current system disk
1217: 1840+4	E52B  4F      		LD	C,A		; .
1218: 1844+7	E52C  1E00    		LD	E,0		; Set autoselect bit
1219: 1851+17	E52E  CD90E4  		CALL	SELDSK		; Select the system disk
1220: 1868+4	E531  7C      		LD	A,H		; Check for a select error
1221: 1872+4	E532  B5      		OR	L		; .
1222: 1876+7+5	E533  2867    		JR	Z,WBERR		; Select error -- try again
1223:				
1224: 1883+10	E535  010000  		LD	BC,0		; Start reading from track 0
1225: 1893+17	E538  CD76E4  		CALL	SETTRK		; .
1226: 1910+7	E53B  0610    		LD	B,NSECTS	; Set the # of sectors to read
1227: 1917+7	E53D  0E01    		LD	C,1		; Start from sector 1 of track 0
1228: 1924+10	E53F  2100CC  		LD	HL,CCP		; Where we want the data to go
1229:     -	E542          	WBLOOP:
1230: 1934+11	E542  C5      		PUSH	BC		; Save sector count
1231: 1945+11	E543  E5      		PUSH	HL		; and DMA address
1232: 1956+17	E544  CD7FE4  		CALL	SETSEC		; Set the sector to read next
1233: 1973+10	E547  C1      		POP	BC		; Get the DMA address
1234: 1983+11	E548  C5      		PUSH	BC		; Save it back
1235: 1994+17	E549  CD87E4  		CALL	SETDMA		; Set the current DMA
1236: 2011+17	E54C  CD99E6  		CALL	READ		; Read the sector
1237: 2028+4	E54F  B7      		OR	A		; Check for errors
1238: 2032+7+5	E550  204A    		JR	NZ,WBERR	; Disp msg & try again on error
1239:				
1240: 2039+10	E552  E1      		POP	HL		; Get DMA address
1241: 2049+10	E553  C1      		POP	BC		; Get count & current sector
1242: 2059+10	E554  118000  		LD	DE,128		; Update DMA address
1243: 2069+11	E557  19      		ADD	HL,DE		; .
1244: 2080+4	E558  0C      		INC	C		; Bump sector count
1245: 2084+13	E559  3A20EF  		LD	A,(CPMSPT)	; Get sectors/track for this disk
1246: 2097+4	E55C  B9      		CP	C		; Are we at the end of track yet?
1247: 2101+7+5	E55D  200C    		JR	NZ,NXTSEC	; No,  just get the next sector
1248: 2108+11	E55F  C5      		PUSH	BC		; Yes, save count & current sector
1249: 2119+20	E560  ED4B15EF		LD	BC,(CPMTRK)	; Bump current track
1250: 2139+6	E564  03      		INC	BC		; .
1251: 2145+17	E565  CD76E4  		CALL	SETTRK		; .
1252: 2162+10	E568  C1      		POP	BC		; Restore count
1253: 2172+7	E569  0E00    		LD	C,0		; Reset sector to 0
1254:     -	E56B          	NXTSEC:
1255: 2179+8+5	E56B  10D5    		DJNZ	WBLOOP
1256:				
1257:				; NOTE: WBOOT falls through to GOCPM
1258:				;	*	*	*	*	*	*	*	*
1259:				;
1260:				;  GOCPM	Setup CP/M vectors and jump to CP/M
1261:				;
1262:				;	*	*	*	*	*	*	*	*
1263:     -	E56D          	GOCPM:
1264: 2187+10	E56D  318000  		LD	SP,80H		; set stack pointer
1265: 2197+4	E570  AF      		XOR	A
1266: 2201+13	E571  3219EF  		LD	(HSTACT),A	; Clear the host active flag
1267: 2214+13	E574  321AEF  		LD	(HSTWRT),A	; Clear the host written flag
1268: 2227+13	E577  321BEF  		LD	(UNACNT),A	; clear unacnt value
1269:				
1270: 2240+7	E57A  3EC3    		LD	A,0C3H		; Setup the warm boot vector
1271: 2247+13	E57C  320000  		LD	(0),A		; .
1272: 2260+10	E57F  2103E2  		LD	HL,WBOOTE	; .
1273: 2270+16	E582  220100  		LD	(1),HL		; .
1274: 2286+13	E585  320500  		LD	(5),A		; and the BDOS vector
1275: 2299+10	E588  2106D4  		LD	HL,BDOS		; .
1276: 2309+16	E58B  220600  		LD	(6),HL		; .
1277: 2325+10	E58E  018000  		LD	BC,80H		; Setup the default DMA
1278: 2335+17	E591  CD87E4  		CALL	SETDMA		; .
1279: 2352+4	E594  FB      		EI			; Enable interrupts
1280: 2356+13	E595  3A0400  		LD	A,(CDISK)	; Get current disk/user
1281: 2369+4	E598  4F      		LD	C,A		; .
1282: 2373+10	E599  C300CC  		JP	CCP		; And go to CP/M ...
1283:				
1284:				;	*	*	*	*	*	*	*	*
1285:				;
1286:				;  WBERR	Display error msg on warm boot error and try again.
1287:				;
1288:				;	*	*	*	*	*	*	*	*
1289:     -	E59C          	WBERR:
1290: 2383+10	E59C  21A4E5  		LD	HL,BOOTMSG	; Warm boot error -- display
1291: 2393+17	E59F  CD1BE5  		CALL	PUTS		; .  boot failed message and
1292: 2410+12	E5A2  1881    		JR	WBOOT		; .  try again ...
1293:     -	E5A4          	BOOTMSG:
1294:     -	E5A4  0D0A424F		DEFB	CR,LF,'BOOT FAILED!',0
	              4F542046
	              41494C45
	              442100
1295:				
1296:				
1297:				
1298:				;	*	*	*	*	*	*	*	*
1299:				;
1300:				;  SELFLP	Floppy disk select routine
1301:				;
1302:				;  See if the disk has been accessed since the last warm or cold
1303:				;  boot (bit 0 of the E register is non-zero).  If true, seek to
1304:				;  track 2 and read the ID to determine if the disk is SS or DS,
1305:				;  48tpi or 96tpi, and in a 48tpi or 96tpi drive.  Set up the disk
1306:				;  access tables as appropriate.
1307:				;
1308:				;	*	*	*	*	*	*	*	*
1309:     -	E5B3          	SELFLP:
1310: 2422+8	E5B3  CB43    		BIT	0,E		; Check for new mount since boot
1311: 2430+7+5	E5B5  205F    		JR	NZ,SELEND	; Not new, no need to determine type
1312: 2437+17	E5B7  CDA8E9  		CALL	MAPTYPE		; Clear double step bit
1313: 2454+15	E5BA  CBB6    		RES	6,(HL)		; .
1314: 2469+17	E5BC  CDF8E9  		CALL	GETTYPE		; Set type byte to SS48tpi
1315: 2486+10	E5BF  3686    		LD	(HL),SSDD48	; .
1316: 2496+17	E5C1  CDC7E9  		CALL	SETUP		; Setup parameters for SSDD
1317: 2513+17	E5C4  CD11E9  		CALL	RESTORE		; Restore floppy to track 00
1318: 2530+10	E5C7  C2E1E4  		JP	NZ,SELERR	; Error on restore, give select err
1319: 2540+7	E5CA  3E02    		LD	A,2		; Seek to track 2
1320: 2547+13	E5CC  3215EF  		LD	(CPMTRK),A	; .
1321: 2560+17	E5CF  CD49E9  		CALL	SEEK		; .
1322: 2577+13	E5D2  3A46F3  		LD	A,(IDSAVE+3)	; Get sector size (bytes/sector)
1323: 2590+8	E5D5  CB4F    		BIT	1,A		; Bit 1 non-zero means 512 or 1024
1324: 2598+10	E5D7  CAE1E4  		JP	Z,SELERR	; 128, 256 = err for AMPRO fmt
1325: 2608+7	E5DA  E601    		AND	01H		; Reset all but bit 0
1326: 2615+4	E5DC  87      		ADD	A,A		; *2 ... now 0=48tpi, 2=96tpi
1327: 2619+4	E5DD  4F      		LD	C,A		; Save in C reg for the moment
1328: 2623+13	E5DE  3A45F3  		LD	A,(IDSAVE+2)	; Get sector #
1329: 2636+7	E5E1  FE11    		CP	DSBIAS+1	; Compare to DS bias (16+1)
1330: 2643+7+5	E5E3  3801    		JR	C,SELSS
1331: 2650+4	E5E5  0C      		INC	C		; Bump pointer if DS
1332: 2654+7	E5E6  0600    	SELSS:	LD	B,0		; BC now contains offset to type
1333: 2661+17	E5E8  CDF8E9  		CALL	GETTYPE		; Get ptr to type byte
1334: 2678+4	E5EB  EB      		EX	DE,HL		; Save ptr in DE
1335: 2682+10	E5EC  2153E6  		LD	HL,TYPTBL	; Get type table base
1336: 2692+11	E5EF  09      		ADD	HL,BC		; Add offset
1337: 2703+7	E5F0  7E      		LD	A,(HL)		; Get actual type byte
1338: 2710+7	E5F1  12      		LD	(DE),A		; Save in PHYTAB
1339:				
1340: 2717+17	E5F2  CD38E6  		CALL	GETDPT		; Get ptr to DPT
1341: 2734+10	E5F5  110A00  		LD	DE,10		; Bump by 10 to get ptr to DPB
1342: 2744+11	E5F8  19      		ADD	HL,DE		; .
1343: 2755+4	E5F9  EB      		EX	DE,HL		; Save ptr in DE
1344: 2759+10	E5FA  2157E6  		LD	HL,DPBTBL	; Get DPB ptr base
1345: 2769+11	E5FD  09      		ADD	HL,BC		; Add offset
1346: 2780+11	E5FE  09      		ADD	HL,BC		; Add offset again (word ptr)
1347: 2791+7	E5FF  7E      		LD	A,(HL)		; Get first byte of DPB ptr
1348: 2798+7	E600  12      		LD	(DE),A		; Save it
1349: 2805+6	E601  13      		INC	DE		; Bump pointers
1350: 2811+6	E602  23      		INC	HL		; .
1351: 2817+7	E603  7E      		LD	A,(HL)		; Get second byte of DPB ptr
1352: 2824+7	E604  12      		LD	(DE),A		; Save it
1353:				
1354: 2831+13	E605  3A43F3  		LD	A,(IDSAVE)	; Get track number
1355: 2844+4	E608  3D      		DEC	A		; Track=1 means set double step
1356: 2848+7+5	E609  2806    		JR	Z,SET$DSTEP
1357: 2855+4	E60B  3D      		DEC	A		; Track=2 means normal step
1358: 2859+7+5	E60C  2808    		JR	Z,SELEND
1359: 2866+10	E60E  C3E1E4  		JP	SELERR		; Any other value = select err
1360:				
1361:     -	E611          	SET$DSTEP:
1362: 2876+17	E611  CDA8E9  		CALL	MAPTYPE		; Map byte for this drive,
1363: 2893+15	E614  CBF6    		SET	6,(HL)		; set the double step bit.
1364:				
1365:				; NOTE: We fall through to SELEND ...
1366:				;	*	*	*	*	*	*	*	*
1367:				;
1368:				;  SELEND	Compute proper deblocker variables and DPT addr
1369:				;
1370:				;  Driver types 1, 2, and 3 all re-enter here.
1371:				;
1372:				;	*	*	*	*	*	*	*	*
1373:     -	E616          	SELEND:
1374: 2908+17	E616  CDF8E9  		CALL	GETTYPE		; Get current type byte
1375: 2925+4	E619  47      		LD	B,A		; Save for a moment
1376: 2929+7	E61A  E603    		AND	3		; Mask all but sector shift bits
1377: 2936+13	E61C  3222EF  		LD	(SECSHF),A	; Save sector shift value
1378: 2949+4	E61F  5F      		LD	E,A		; Get sector shift byte from table
1379: 2953+7	E620  1600    		LD	D,0		; .
1380: 2960+10	E622  215FE6  		LD	HL,SEC$MSK$TBL	; .
1381: 2970+11	E625  19      		ADD	HL,DE		; .
1382: 2981+7	E626  7E      		LD	A,(HL)		; .
1383: 2988+13	E627  3221EF  		LD	(SECMSK),A	; Save it
1384:				
1385: 3001+4	E62A  78      		LD	A,B		; Get type byte back
1386: 3005+4	E62B  1F      		RRA			; Shift over to move alloc size
1387: 3009+4	E62C  1F      		RRA			; .  to the proper position
1388: 3013+7	E62D  E603    		AND	3		; Mask all but alloc bits
1389: 3020+4	E62F  5F      		LD	E,A		; Get initial unalloc from table
1390:				;	MVI	D,0		; . already zero from start of routine
1391: 3024+10	E630  2163E6  		LD	HL,M$UNACT$TBL	; .
1392: 3034+11	E633  19      		ADD	HL,DE		; .
1393: 3045+7	E634  7E      		LD	A,(HL)		; .
1394: 3052+13	E635  320BEF  		LD	(MUNACT),A	; Save it
1395:				
1396:				; NOTE: We fall through to GETDPT . . .
1397:				;	*	*	*	*	*	*	*	*
1398:				;
1399:				;  GETDPT	Calculate the DPH address for the current logical disk
1400:				;
1401:				;  Entry with the DPH vector in DPHDRV, exits with the DPH address in
1402:				;  the HL register pair, and the current DPB saved at CURDPB (primarily
1403:				;  for the warm boot routine).
1404:				;
1405:				;	*	*	*	*	*	*	*	*
1406:     -	E638          	GETDPT:
1407: 3065+13	E638  3A32F3  		LD	A,(DPHDRV)	; Get DPH pointer
1408: 3078+4	E63B  5F      		LD	E,A		; .
1409: 3082+7	E63C  1600    		LD	D,0		; . ****
1410: 3089+10	E63E  2180E2  		LD	HL,DPBASE	; .
1411: 3099+11	E641  19      		ADD	HL,DE		; .
1412: 3110+4	E642  EB      		EX	DE,HL		; save it (need to return it in 'hl')
1413: 3114+7	E643  2E0A    		LD	L,10		; add offset to dpb 'h'=zero from ****
1414: 3121+11	E645  19      		ADD	HL,DE		; .
1415: 3132+7	E646  7E      		LD	A,(HL)		; Copy DPB ptr to HL
1416: 3139+6	E647  23      		INC	HL		; .
1417: 3145+7	E648  66      		LD	H,(HL)		; .
1418: 3152+4	E649  6F      		LD	L,A		; .
1419: 3156+16	E64A  2241F3  		LD	(CURDPB),HL	; Save current DPB pointer
1420: 3172+7	E64D  7E      		LD	A,(HL)		; Get sectors-per-track
1421: 3179+13	E64E  3220EF  		LD	(CPMSPT),A	; Save it
1422: 3192+4	E651  EB      		EX	DE,HL		; get dph pointer
1423: 3196+10	E652  C9      		RET			; Leave with DPH pointer in HL
1424:				
1425:     -	E653          	TYPTBL:				; Drive type bytes
1426:     -	E653  86      		DEFB	SSDD48
1427:     -	E654  C6      		DEFB	DSDD48
1428:     -	E655  87      		DEFB	SSDD96
1429:     -	E656  C7      		DEFB	DSDD96
1430:				
1431:     -	E657          	DPBTBL:				; DBP pointers
1432:     -	E657  18E3    		DEFW	SPARM
1433:     -	E659  27E3    		DEFW	DPARM
1434:     -	E65B  27E3    		DEFW	DPARM
1435:     -	E65D  36E3    		DEFW	QPARM
1436:				
1437:     -	E65F          	SEC$MSK$TBL:
1438:								; Sector mask table
1439:     -	E65F  00      		DEFB	00H
1440:     -	E660  01      		DEFB	01H
1441:     -	E661  03      		DEFB	03H
1442:     -	E662  07      		DEFB	07H
1443:				
1444:     -	E663          	M$UNACT$TBL:
1445:								; Initial unalloc count table
1446:     -	E663  08      		DEFB	8
1447:     -	E664  10      		DEFB	16
1448:     -	E665  20      		DEFB	32
1449:     -	E666  40      		DEFB	64
1450:				
1451:				;	*	*	*	*	*	*	*	*
1452:				;
1453:				;	SELECT THE E-DISK DRIVE
1454:				;
1455:				;	Builds the appropriate tables, and attempts to re-zero the
1456:				;	drive. Returns with Select Error if can't re-zero.
1457:				;
1458:				;	*	*	*	*	*	*	*	*
1459:     -	E667          	SELEDSK:
1460: 3206+8	E667  CB43    		BIT	0,E		; Check for new mount since boot
1461: 3214+7+5	E669  20AB    		JR	NZ,SELEND	; Not new, no need to determine type
1462: 3221+17	E66B  CDF8E9  		CALL	GETTYPE		; Get type byte & pointer
1463: 3238+8	E66E  CB6F    		BIT	5,A		; Continuous sector numbers?
1464: 3246+7+5	E670  2812    		JR	Z,NOTCONT	; No,  don't bother computing E-adj
1465: 3253+7	E672  E603    		AND	03H		; Yes, compute E-adj from sector
1466: 3260+20	E674  ED4B59E3		LD	BC,(EPARM-1)	; .  size and sectors per track
1467: 3280+7	E678  0EFF    		LD	C,0FFH		; .  (A=count,B=SPT,C=mask)
1468:     -	E67A          	SELESHIFT:
1469:								; .
1470: 3287+4	E67A  B7      		OR	A		; .  Test if done & clear carry
1471: 3291+7+5	E67B  280A    		JR	Z,SDONE		; .  Yes, save parameter
1472: 3298+8	E67D  CB19    		RR	C		; .  (Rotate C right)
1473: 3306+8	E67F  CB18    		RR	B		; .  (Rotate B right)
1474: 3314+4	E681  3D      		DEC	A		; .  Decrement count
1475: 3318+12	E682  18F6    		JR	SELESHIFT	; .  Next shift ...
1476:     -	E684          	NOTCONT:
1477: 3330+10	E684  010000  		LD	BC,0		; Not continuous, set adj to zero
1478:     -	E687          	SDONE:
1479: 3340+4	E687  78      		LD	A,B		; Shifts done, get computed E-adj
1480: 3344+4	E688  A1      		AND	C		; Mask extra bits off
1481: 3348+13	E689  325CF3  		LD	(ESECADJ),A	; Save as proper adj
1482: 3361+17	E68C  CDC7E9  		CALL	SETUP		; Setup parameters for the E-disk
1483: 3378+17	E68F  CD11E9  		CALL	RESTORE		; Restore floppy to track 00
1484: 3395+4	E692  3C      		INC	A		; Check for error during restore
1485: 3399+10	E693  CAE1E4  		JP	Z,SELERR	; Error code, return with select err
1486: 3409+10	E696  C316E6  		JP	SELEND		; No error, finish the select
1487:				
1488:				;---------------------------------------------------------------
1489:				;
1490:				;	READ CP/M SECTOR FROM THE CURRENTLY SELECTED DISK
1491:				;
1492:				;	ENTRY VIA THE BIOS JUMP TABLE
1493:				;
1494:				;--------------------------------------------------------------
1495:     -	E699          	READ:
1496: 3419+20	E699  ED7311ED		LD	(OLDSTK),SP	; save old stack
1497: 3439+10	E69D  310FED  		LD	SP,LOCSTK	; set local stack
1498: 3449+13	E6A0  3A22EF  		LD	A,(SECSHF)	; secshf = 0 if 128 byte sector size
1499: 3462+4	E6A3  A7      		AND	A
1500: 3466+10	E6A4  CACDE7  		JP	Z,READHST	; IF 128 BYTES
1501: 3476+4	E6A7  AF      		XOR	A
1502: 3480+13	E6A8  321BEF  		LD	(UNACNT),A
1503: 3493+4	E6AB  3C      		INC	A		; 'a' = 1
1504: 3497+13	E6AC  3226EF  		LD	(READOP),A	; READ OPERATION
1505: 3510+13	E6AF  3225EF  		LD	(RSFLAG),A	; MUST READ DATA
1506: 3523+7	E6B2  3E02    		LD	A,WRUAL
1507: 3530+13	E6B4  3227EF  		LD	(WRTYPE),A	; TREAT AS UNALLOC
1508: 3543+12	E6B7  185E    		JR	RWOPER		; TO PERFORM THE READ
1509:				
1510:				;---------------------------------------------------------------
1511:				;
1512:				;	WRITE CP/M SECTOR FROM THE CURRENTLY SELECTED DISK
1513:				;
1514:				;	ENTRY VIA THE BIOS JUMP TABLE
1515:				;
1516:				;--------------------------------------------------------------
1517:     -	E6B9          	WRITE:
1518: 3555+20	E6B9  ED7311ED		LD	(OLDSTK),SP	; save callers stack
1519: 3575+10	E6BD  310FED  		LD	SP,LOCSTK	; set local stack
1520: 3585+13	E6C0  3A22EF  		LD	A,(SECSHF)	; secshf = 0 if 128 bytes
1521: 3598+4	E6C3  A7      		AND	A
1522: 3602+10	E6C4  CACAE7  		JP	Z,WRITEHST	; IF 128 BYTES
1523: 3612+4	E6C7  AF      		XOR	A		; 0 TO ACCUMULATOR
1524: 3616+13	E6C8  3226EF  		LD	(READOP),A	; NOT A READ OPERATION
1525: 3629+4	E6CB  79      		LD	A,C		; WRITE TYPE IN C
1526: 3633+13	E6CC  3227EF  		LD	(WRTYPE),A
1527: 3646+7	E6CF  FE02    		CP	WRUAL		; WRITE UNALLOCATED?
1528: 3653+7+5	E6D1  200B    		JR	NZ,CHKUNA
1529:				
1530:				;	WRITE TO UNALLOCATED, SET PARAMETERS
1531:				;	FOR EDSK, WE NEED TO CHECK TO SEE IF SEKDSK IS THE E DISK.
1532:				;	IF SO, THEN UNACNT WILL BE SET ACCORDING TO THE DISK TYPE.
1533:				;	FOR AMPRO DISKS, ITS ALWAYS BLKSIZ/128.
1534:				
1535: 3660+10	E6D3  210BEF  		LD	HL,MUNACT
1536: 3670+10	E6D6  111BEF  		LD	DE,UNACNT
1537: 3680+10	E6D9  010500  		LD	BC,5
1538: 3690+16+5	E6DC  EDB0    		LDIR
1539:				
1540:     -	E6DE          	CHKUNA:
1541:				;	CHECK FOR WRITE TO UNALLOCATED SECTOR
1542:				;	MORE UNALLOCATED RECORDS REMAIN
1543:				;	DISKS ARE THE SAME
1544:				;	TRACKS ARE THE SAME
1545:				
1546: 3706+4	E6DE  AF      		XOR	A		; clear 'a'
1547: 3710+10	E6DF  211BEF  		LD	HL,UNACNT
1548: 3720+7	E6E2  B6      		OR	(HL)		; see if any more remain
1549: 3727+7+5	E6E3  282A    		JR	Z,ALLOC		; no more remain
1550: 3734+11	E6E5  35      		DEC	(HL)		; unacnt -1
1551: 3745+6	E6E6  23      		INC	HL		; 'hl' = unadsk
1552:				
1553:				; get ready for block match
1554:				; sekdsk=unadsk, sektrk=unatrk, seksec=unasec ?
1555:				
1556: 3751+10	E6E7  110CEF  		LD	DE,SEKDSK	; 
1557: 3761+10	E6EA  010400  		LD	BC,4
1558: 3771+7	E6ED  1A      	MORUNA:	LD	A,(DE)
1559: 3778+16	E6EE  EDA1    		CPI
1560: 3794+7+5	E6F0  201D    		JR	NZ,ALLOC	; no match
1561: 3801+6	E6F2  13      		INC	DE		; next byte
1562: 3807+10	E6F3  EAEDE6  		JP	PE,MORUNA	; count not over
1563:				
1564: 3817+6	E6F6  2B      		DEC	HL		; correct 'hl' to unasec
1565:				
1566:				; MATCH, MOVE TO NEXT SECTOR FOR FUTURE REF
1567:				
1568: 3823+11	E6F7  34      		INC	(HL)		; UNASEC = UNASEC+1
1569: 3834+7	E6F8  7E      		LD	A,(HL)		; END OF TRACK?
1570: 3841+4	E6F9  EB      		EX	DE,HL		; save 'hl' for overflow
1571: 3845+16	E6FA  2A41F3  		LD	HL,(CURDPB)	; get current DPB as set by select
1572: 3861+7	E6FD  BE      	EMATCH:	CP	(HL)		; see if end of track
1573: 3868+7+5	E6FE  3809    		JR	C,NOOVF		; SKIP IF NO OVERFLOW
1574:				
1575:				; OVERFLOW TO NEXT TRACK
1576:				
1577: 3875+4	E700  AF      		XOR	A
1578: 3879+7	E701  12      		LD	(DE),A		; unasec 'de' = 0
1579: 3886+16	E702  2A1DEF  		LD	HL,(UNATRK)
1580: 3902+6	E705  23      		INC	HL
1581: 3908+16	E706  221DEF  		LD	(UNATRK),HL
1582:				
1583:				; MATCH FOUND, MARK AS UNNECESSARY READ
1584:				
1585: 3924+4	E709  AF      	NOOVF:	XOR	A		; 0 TO ACCUMULATOR
1586: 3928+13	E70A  3225EF  		LD	(RSFLAG),A	; RSFLAG = 0
1587: 3941+12	E70D  1809    		JR	RWOPER+1	; TO PERFORM THE WRITE
1588:				
1589:				; NOT AN UNALLOCATED RECORD, REQUIRES PRE-READ
1590:				
1591: 3953+4	E70F  AF      	ALLOC:	XOR	A		; 0 TO ACCUM
1592: 3957+13	E710  321BEF  		LD	(UNACNT),A	; UNACNT = 0
1593: 3970+4	E713  3C      		INC	A		; 1 TO ACCUM
1594: 3974+13	E714  3225EF  		LD	(RSFLAG),A	; RSFLAG = 1
1595:				
1596:				; ENTER HERE TO PERFORM THE READ/WRITE
1597:				
1598: 3987+4	E717  AF      	RWOPER:	XOR	A		; ZERO TO ACCUM
1599: 3991+13	E718  3224EF  		LD	(ERFLAG),A	; NO ERRORS (YET)
1600: 4004+13	E71B  3A22EF  		LD	A,(SECSHF)
1601: 4017+4	E71E  47      		LD	B,A
1602: 4021+13	E71F  3A0FEF  		LD	A,(SEKSEC)	; COMPUTE HOST SECTOR
1603:				
1604:     -	E722          	SLOOP:
1605: 4034+8	E722  CB3F    		SRL	A		; shift 'a' right, msb = 0
1606: 4042+8+5	E724  10FC    		DJNZ	SLOOP
1607: 4050+13	E726  3218EF  		LD	(SEKHST),A	; HOST SECTOR TO SEEK
1608:				
1609:				;				ACTIVE HOST SECTOR?
1610: 4063+10	E729  2119EF  		LD	HL,HSTACT	; HOST ACTIVE FLAG
1611: 4073+7	E72C  7E      		LD	A,(HL)
1612: 4080+10	E72D  3601    		LD	(HL),1		; ALWAYS BECOMES 1
1613: 4090+4	E72F  B7      		OR	A		; WAS IT ALREADY?
1614: 4094+7+5	E730  282B    		JR	Z,FILHST
1615:				
1616:				;				HOST BUFFER ACTIVE, SAME AS SEEK BUFFER?
1617: 4101+10	E732  110CEF  		LD	DE,SEKDSK
1618: 4111+10	E735  2110EF  		LD	HL,HSTDSK
1619: 4121+10	E738  010300  		LD	BC,3
1620: 4131+7	E73B  1A      	MATMOR:	LD	A,(DE)		; sekdsk=hstdsk, sektrk=hsttrk ?
1621: 4138+16	E73C  EDA1    		CPI
1622: 4154+7+5	E73E  200A    		JR	NZ,NOMATCH
1623: 4161+6	E740  13      		INC	DE
1624: 4167+10	E741  EA3BE7  		JP	PE,MATMOR
1625: 4177+13	E744  3A18EF  		LD	A,(SEKHST)	; sekhst=hstsec ?
1626: 4190+7	E747  BE      		CP	(HL)
1627: 4197+7+5	E748  2836    		JR	Z,MATCH		; match
1628:				
1629:     -	E74A          	NOMATCH:
1630:				;				PROPER DISK, BUT NOT CORRECT SECTOR
1631: 4204+13	E74A  3A1AEF  		LD	A,(HSTWRT)	; HOST WRITTEN?
1632: 4217+4	E74D  B7      		OR	A
1633: 4221+13	E74E  3A10EF  		LD	A,(HSTDSK)	; SELECT HOST AS DISK TO WORK ON
1634: 4234+13	E751  3230F3  		LD	(LOGDSK),A	; SET LOGICAL DRIVE = BUFFERS DRIVE
1635: 4247+16	E754  2A11EF  		LD	HL,(HSTTRK)
1636: 4263+16	E757  2215EF  		LD	(CPMTRK),HL
1637: 4279+10+7	E75A  C4CAE7  		CALL	NZ,WRITEHST	; CLEAR HOST BUFF
1638:				
1639: 4289+13	E75D  3A0CEF  	FILHST:	LD	A,(SEKDSK)	; May have to fill host buffer
1640: 4302+13	E760  3210EF  		LD	(HSTDSK),A
1641: 4315+13	E763  3230F3  		LD	(LOGDSK),A	; UPDATE LOGICAL DRIVE 
1642: 4328+16	E766  2A0DEF  		LD	HL,(SEKTRK)
1643: 4344+16	E769  2211EF  		LD	(HSTTRK),HL
1644: 4360+16	E76C  2215EF  		LD	(CPMTRK),HL
1645: 4376+13	E76F  3A18EF  		LD	A,(SEKHST)
1646: 4389+13	E772  3213EF  		LD	(HSTSEC),A
1647: 4402+13	E775  3A25EF  		LD	A,(RSFLAG)	; NEED TO READ?
1648: 4415+4	E778  B7      		OR	A
1649: 4419+10+7	E779  C4CDE7  		CALL	NZ,READHST	; YES, IF 1
1650: 4429+4	E77C  AF      		XOR	A		; 0 TO ACCUM
1651: 4433+13	E77D  321AEF  		LD	(HSTWRT),A	; NO PENDING WRITE
1652:				
1653:				;
1654:				;	COPY DATA TO OR FROM BUFFER
1655:				;	EDSK: SECTOR MASK (SECMSK) MUST BE A VARIABLE FOR EDISK AND
1656:				;	IS CALCULATED BY (HSTSIZ/128)-1. THIS IS THREE FOR AMPRO,
1657:				;	KAYPRO, AND OTHER 512-BYTE SECTORS, AND 1 FOR 256 BYTE SECTORS.
1658:				;
1659: 4446+13	E780  3A0FEF  	MATCH:	LD	A,(SEKSEC)	; MASK BUFFER NUMBER
1660: 4459+10	E783  2121EF  		LD	HL,SECMSK
1661: 4469+7	E786  A6      		AND	(HL)		; LEAST SIGNIF BITS
1662: 4476+4	E787  87      		ADD	A,A		; x2
1663: 4480+4	E788  6F      		LD	L,A		; Get offset from table
1664: 4484+7	E789  2600    		LD	H,0
1665: 4491+10	E78B  11D5E7  		LD	DE,BUFTBL	; Buffer table
1666: 4501+11	E78E  19      		ADD	HL,DE		; 'hl' points to offset address
1667: 4512+7	E78F  7E      		LD	A,(HL)
1668: 4519+6	E790  23      		INC	HL
1669: 4525+7	E791  66      		LD	H,(HL)
1670: 4532+4	E792  6F      		LD	L,A		; 'hl' has hostbuffer address
1671: 4536+20	E793  ED5B28EF		LD	DE,(DMAADR)	; load 'de' dmaadress
1672: 4556+10	E797  018000  		LD	BC,128		; set 'bc' up form 128 byte transfer
1673: 4566+13	E79A  3A26EF  		LD	A,(READOP)	; WHICH WAY?
1674: 4579+4	E79D  B7      		OR	A
1675: 4583+7+5	E79E  2006    		JR	NZ,RWMOVE
1676:				
1677:				;				WRITE OPERATION, MARK AND SWITCH DIRECTION
1678: 4590+7	E7A0  3E01    		LD	A,1
1679: 4597+13	E7A2  321AEF  		LD	(HSTWRT),A	; HSTWRT = 1
1680: 4610+4	E7A5  EB      		EX	DE,HL		; SOURCE/DEST SWAP
1681:				
1682: 4614+16+5	E7A6  EDB0    	RWMOVE:	LDIR		; 'hl' = source, 'de' = destination
1683:				
1684:				;	DATA HAS BEEN MOVED TO/FROM HOST BUFFER
1685:				
1686: 4630+13	E7A8  3A27EF  		LD	A,(WRTYPE)	; WRITE TYPE
1687: 4643+7	E7AB  FE01    		CP	WRDIR		; TO DIRECTORY?
1688: 4650+13	E7AD  3A24EF  		LD	A,(ERFLAG)	; IN CASE OF ERRORS
1689: 4663+5+6	E7B0  C0      		RET	NZ		; NO FURTHER PROCESSING
1690:				
1691:				;	CLEAR HOST BUFFER FOR DIRECTORY WRITE
1692:				
1693: 4668+4	E7B1  B7      		OR	A		; ERRORS?
1694: 4672+5+6	E7B2  C0      		RET	NZ		; SKIP IF SO
1695: 4677+4	E7B3  AF      		XOR	A		; 0 TO ACCUM
1696: 4681+13	E7B4  321AEF  		LD	(HSTWRT),A	; BUFFER WRITTEN
1697: 4694+13	E7B7  3A10EF  		LD	A,(HSTDSK)
1698: 4707+13	E7BA  3230F3  		LD	(LOGDSK),A
1699: 4720+16	E7BD  2A11EF  		LD	HL,(HSTTRK)
1700: 4736+16	E7C0  2215EF  		LD	(CPMTRK),HL
1701: 4752+17	E7C3  CDCAE7  		CALL	WRITEHST
1702: 4769+13	E7C6  3A24EF  		LD	A,(ERFLAG)
1703: 4782+10	E7C9  C9      		RET
1704:				
1705:     -	E7CA          	WRITEHST:
1706:								; LOGDSK = HOST DISK #, CPMTRK = HOST TRACK #,
1707:								; HSTSEC = HOST SECT #. WRITE "HSTSIZ" BYTES
1708:								; FROM HSTBUF AND RETURN ERROR FLAG IN ERFLAG.
1709:								; RETURN ERFLAG NON-ZERO IF ERROR
1710:				
1711: 4792+4	E7CA  AF      		XOR	A
1712: 4796+12	E7CB  1802    		JR	HOSTDO
1713:				
1714:     -	E7CD          	READHST:
1715:								; LOGDSK = HOST DISK #, CPMTRK = HOST TRACK #,
1716:								; HSTSEC = HOST SECT #. READ "HSTSIZ" BYTES
1717:								; INTO HSTBUF AND RETURN ERROR FLAG IN ERFLAG.
1718:				
1719: 4808+7	E7CD  3E01    		LD	A,1
1720: 4815+13	E7CF  3250F3  	HOSTDO:	LD	(RWHOST),A
1721: 4828+10	E7D2  C3A6E4  	HOSTIO:	JP	PDRVR		; SELECT NEXT ROUTINE VIA PDRVR
1722:				;
1723:				; Buffer table, determine start address of host buffer for read/write
1724:				;
1725:     -	E7D5  2AEF    	BUFTBL:	DEFW	HSTBUF+0000
1726:     -	E7D7  AAEF    		DEFW	HSTBUF+0128
1727:     -	E7D9  2AF0    		DEFW	HSTBUF+0256
1728:     -	E7DB  AAF0    		DEFW	HSTBUF+0384
1729:     -	E7DD  2AF1    		DEFW	HSTBUF+0512
1730:     -	E7DF  AAF1    		DEFW	HSTBUF+0640
1731:     -	E7E1  2AF2    		DEFW	HSTBUF+0768
1732:     -	E7E3  AAF2    		DEFW	HSTBUF+0896
1733:				;
1734:				;--------------------------------------------------------------------
1735:				;
1736:				;	FLOPPY DISK READ/WRITE HOST ROUTINES
1737:				;
1738:				;-------------------------------------------------------------------
1739:				
1740:				;	*	*	*	*	*	*	*	*
1741:				;
1742:				;  FLOPPY	Floppy disk dispatcher -- driver code (01)
1743:				;
1744:				;  Enter with operation code in the A register as:
1745:				;
1746:				;	FF	Select Disk
1747:				;	00	Write Disk
1748:				;	01	Read Disk
1749:				;
1750:				;	*	*	*	*	*	*	*	*
1751:     -	E7E5          	FLOPPY:
1752: 4838+4	E7E5  3C      		INC	A		; Code = select?
1753: 4842+10	E7E6  CAB3E5  		JP	Z,SELFLP	; Yes, perform a floppy select
1754:								; No,  perform host read or write
1755:     -	E7E9          	FLOPPYIO:
1756: 4852+17	E7E9  CDC7E9  		CALL	SETUP		; OUTPUT TO DRIVE SELECT REGISTER
1757: 4869+7	E7EC  3E03    		LD	A,FRETRY
1758: 4876+13	E7EE  324FF3  		LD	(TRIES),A
1759:     -	E7F1          	WMI:
1760: 4889+17	E7F1  CDB5E9  		CALL	MAPTRK
1761: 4906+17	E7F4  CD41EA  		CALL	GETTRK		; WHAT TRACK DO WE WANT?
1762: 4923+7	E7F7  BE      		CP	(HL)
1763: 4930+10+7	E7F8  C449E9  		CALL	NZ,SEEK		; IF NOT THERE, GO THERE
1764: 4940+7+5	E7FB  2048    		JR	NZ,RWFAIL	; IN CASE SEEK FAILS
1765:				
1766:				;	TRACK SHOULD BE OK, BUT WE NEED TO SEND IT ANYWAY IN
1767:				;       CASE THE LAST UNIT WAS DIFFERENT (THERE'S ONLY ONE TRACK
1768:				;	REGISTER). THEN LOAD SECTOR AND DO IT...
1769:				
1770: 4947+17	E7FD  CD41EA  		CALL	GETTRK
1771: 4964+11	E800  D3C1    		OUT	(WTRK),A
1772: 4975+17	E802  CD02EA  		CALL	GETSEC
1773:				
1774:				; CHECK FOR DSDD TO ADD SECTOR BIAS IF NOT 'E' DRIVE
1775:				
1776: 4992+4	E805  5F      		LD	E,A		; Save sector # for a moment
1777: 4996+13	E806  3A31F3  		LD	A,(PHYDRV)	; See if this is the E-disk
1778: 5009+7	E809  FE04    		CP	04H		; .  (E-disk is drive "4")
1779: 5016+7	E80B  3E00    		LD	A,0		; Restore sector #
1780: 5023+7+5	E80D  2811    		JR	Z,NOBIAS	; No sector bias if 'E' drive
1781: 5030+11	E80F  E5      		PUSH	HL
1782: 5041+11	E810  D5      		PUSH	DE
1783: 5052+17	E811  CDF8E9  		CALL	GETTYPE		; get disk type
1784: 5069+10	E814  D1      		POP	DE
1785: 5079+10	E815  E1      		POP	HL
1786: 5089+7	E816  E6C0    		AND	0C0H		; Isolate DD, DS indicators
1787: 5096+7	E818  FEC0    		CP	0C0H		; Check DD and DS
1788: 5103+7	E81A  3E00    		LD	A,0		; .
1789: 5110+7+5	E81C  2002    		JR	NZ,NOBIAS	; Not DSDD, no bias
1790: 5117+7	E81E  C610    		ADD	A,DSBIAS	; Add double sided bias
1791:     -	E820          	NOBIAS:
1792: 5124+4	E820  83      		ADD	A,E		; Add sector # to bias
1793: 5128+11	E821  D3C2    		OUT	(WSEC),A	; Send sector # to FDC
1794: 5139+17	E823  CDC7E9  		CALL	SETUP		; Select unit and real side
1795: 5156+17	E826  CD34EA  		CALL	GETBUF		; 
1796: 5173+7	E829  3E02    		LD	A,2		; Set up internal retry counter
1797: 5180+13	E82B  3223EF  		LD	(INT$RETRIES),A	; .
1798: 5193+4	E82E  F3      		di
1799: 5197+13	E82F  3A50F3  		LD	A,(RWHOST)	; Test for read (1) or write (0)
1800: 5210+4	E832  B7      		OR	A		; .
1801: 5214+7+5	E833  2007    		JR	NZ,RDS		; .
1802: 5221+17	E835  CD54E8  		CALL	WRDAT		; Write sector
1803: 5238+4	E838  FB      		ei
1804: 5242+7+5	E839  200A    		JR	NZ,RWFAIL	; Try again if failed
1805: 5249+10	E83B  C9      		RET			; Otherwise return
1806:				
1807: 5259+7	E83C  3E88    	RDS:	LD	A,FREADS	; Indicate read sector
1808: 5266+17	E83E  CD82E8  		CALL	RDATA		; Read sector
1809: 5283+4	E841  FB      		ei
1810: 5287+7+5	E842  2001    		JR	NZ,RWFAIL	; Try again if failed
1811: 5294+10	E844  C9      		RET			; Otherwise return
1812:				
1813: 5304+17	E845  CD11E9  	RWFAIL:	CALL	RESTORE		; Restore to track 00 on failure
1814: 5321+10	E848  214FF3  		LD	HL,TRIES	; Point to retry counter
1815: 5331+11	E84B  35      		DEC	(HL)		; Bump it closer to doom
1816: 5342+7+5	E84C  20A3    		JR	NZ,WMI		; and try again if we can . . .
1817: 5349+7	E84E  3E01    		LD	A,01		; No more tries left
1818: 5356+13	E850  3224EF  		LD	(ERFLAG),A	; Set error flag
1819: 5369+10	E853  C9      		RET			; and return to BDOS w/error
1820:				
1821:				;	*	*	*	*	*	*	*	*
1822:				;
1823:				;  WRDAT	Floppy disk write data routine
1824:				;
1825:				;  This routine writes the data pointed to by the HL register to
1826:				;  the currently selected floppy.
1827:				;
1828:				;  The number of bytes written is determined by the FDC controller
1829:				;  and the ID string currently active for this sector.
1830:				;
1831:				;  Multiple sector transfers are not supported.
1832:				;
1833:				;  NOTE:  The fastest way to test for busy and DRQ is to shift the
1834:				;  status bit right into the carry bit.  Therefore, when busy drops,
1835:				;  the ending status is still shifted right.  The checks for lost
1836:				;  data, write protect, record not found, and crc error must take
1837:				;  this bit shift into account.
1838:				;
1839:				;	*	*	*	*	*	*	*	*
1840:     -	E854          	WRDAT:
1841: 5379+16	E854  2256F3  		LD	(FRWPTR),HL	; Save data ptr in case intr
1842: 5395+17	E857  CDF5E8  		CALL	DWAIT		; Wait until the FDC is ready
1843:     -	E85A          	WRDAT2:
1844: 5412+7	E85A  3EA8    		LD	A,FWRITES	; Set up write sector command
1845: 5419+16	E85C  2A56F3  		LD	HL,(FRWPTR)	; .
1846: 5435+17	E85F  CDB4E8  		CALL	OUTCMD		; Send the command to the FDC
1847:				
1848: 5452+11	E862  DBC4    	WR:	IN	A,(STAT)	; Get FDC status
1849: 5463+4	E864  1F      		RRA			; Test busy bit
1850: 5467+7+5	E865  3009    		JR	NC,WRDONE	; Exit if no busy bit
1851: 5474+4	E867  1F      		RRA			; Test DRQ bit
1852: 5478+7+5	E868  30F8    		JR	NC,WR		; Test status again if no DRQ
1853: 5485+7	E86A  7E      		LD	A,(HL)		; Busy & DRQ ==> OK to write data
1854: 5492+11	E86B  D3C3    		OUT	(WDAT),A	; .
1855: 5503+6	E86D  23      		INC	HL		; Bump pointer to next byte
1856: 5509+12	E86E  18F2    		JR	WR		; Repeat as long as busy is active
1857:				
1858: 5521+8	E870  CB4F    	WRDONE:	BIT	1,A		; Test for lost data
1859: 5529+7+5	E872  20E6    		JR	NZ,WRDAT2
1860:								; Lost data -- Try write cmd again
1861:				
1862: 5536+7	E874  E62C    	WRNLD:	AND	02CH		; Test for WP, RNF, or CRC
1863: 5543+5+6	E876  C8      		RET	Z		; All ok if zero
1864: 5548+13	E877  3A23EF  		LD	A,(INT$RETRIES)	; Get # of internal retries left
1865: 5561+4	E87A  3D      		DEC	A		; Bump count one closer to doom!
1866: 5565+13	E87B  3223EF  		LD	(INT$RETRIES),A	; Save count
1867: 5578+10	E87E  F25AE8  		JP	P,WRDAT2	; Try again if 0, 1, or 2
1868: 5588+10	E881  C9      		RET			; Otherwise return with NZ status
1869:				
1870:				;	*	*	*	*	*	*	*	*
1871:				;
1872:				;  RDATA	Floppy disk read data routine
1873:				;
1874:				;  This routine reads the data from the currently selected floppy
1875:				;  into the area pointed to by the HL register.  This data is from
1876:				;  a read address or read data command.
1877:				;
1878:				;  The number of bytes read is determined by the 1770 controller
1879:				;  and the ID string currently active for this sector.
1880:				;
1881:				;  Multiple sector transfers are not supported.
1882:				;
1883:				;  NOTE:  The fastest way to test for busy and DRQ is to shift the
1884:				;  status bit right into the carry bit.  Therefore, when busy drops,
1885:				;  the ending status is still shifted right.  The checks for lost
1886:				;  data, record not found, and crc error must take this bit shift
1887:				;  into account.
1888:				;
1889:				;	*	*	*	*	*	*	*	*
1890:     -	E882          	RDATA:
1891: 5598+13	E882  3255F3  		LD	(FRWCMD),A	; Save command and data pointer
1892: 5611+16	E885  2256F3  		LD	(FRWPTR),HL	; .  (in case we're interrupted)
1893: 5627+17	E888  CDF5E8  		CALL	DWAIT		; Make sure FDC is ready
1894:     -	E88B          	RDATA2:
1895: 5644+13	E88B  3A55F3  		LD	A,(FRWCMD)	; Get command and data pointer
1896: 5657+16	E88E  2A56F3  		LD	HL,(FRWPTR)	; .
1897: 5673+17	E891  CDB4E8  		CALL	OUTCMD		; Send command to FDC
1898:     -	E894          	RD:
1899: 5690+11	E894  DBC4    		IN	A,(STAT)	; Get FDC status
1900: 5701+4	E896  1F      		RRA			; Test busy bit
1901: 5705+7+5	E897  3009    		JR	NC,RDDONE	; Exit if no busy bit
1902: 5712+4	E899  1F      		RRA			; Test DRQ bit
1903: 5716+7+5	E89A  30F8    		JR	NC,RD		; Test status again if no DRQ
1904: 5723+11	E89C  DBC7    		IN	A,(RDAT)	; Busy & DRQ ==> OK to read data
1905: 5734+7	E89E  77      		LD	(HL),A		; .
1906: 5741+6	E89F  23      		INC	HL		; Bump pointer to next byte
1907: 5747+12	E8A0  18F2    		JR	RD		; Repeat as long as busy is active
1908:     -	E8A2          	RDDONE:
1909: 5759+8	E8A2  CB4F    		BIT	1,A		; Test for lost data
1910: 5767+7+5	E8A4  20E5    		JR	NZ,RDATA2
1911:								; Lost data -- try read again
1912:     -	E8A6          	RDNCD:
1913: 5774+7	E8A6  E60C    		AND	0CH		; Test for RNF or CRC
1914: 5781+5+6	E8A8  C8      		RET	Z		; All ok if zero
1915: 5786+13	E8A9  3A23EF  		LD	A,(INT$RETRIES)	; Get # of internal retries left
1916: 5799+4	E8AC  3D      		DEC	A		; Bump count one closer to doom!
1917: 5803+13	E8AD  3223EF  		LD	(INT$RETRIES),A	; Save count
1918: 5816+10	E8B0  F28BE8  		JP	P,RDATA2	; Try again if 0, 1, or 2
1919: 5826+10	E8B3  C9      		RET			; Otherwise return with NZ status
1920:				
1921:				;	*	*	*	*	*	*	*	*
1922:				;
1923:				;  OUTCMD	Issue a cmd to the 1770 floppy controller
1924:				;
1925:				;	*	*	*	*	*	*	*	*
1926:     -	E8B4          	OUTCMD:
1927: 5836+17	E8B4  CDBFE8  		CALL	MOTOR		; Insure motor on
1928: 5853+11	E8B7  D3C0    	OC0:	OUT	(CMND),A	; Send command to FDC
1929: 5864+7	E8B9  3E0F    		LD	A,15		; Wait 60 us for cmd to set up
1930: 5871+4	E8BB  3D      	OC1:	DEC	A		; . 15 x 4 usec
1931: 5875+7+5	E8BC  20FD    		JR	NZ,OC1
1932: 5882+10	E8BE  C9      		RET
1933:				
1934:				;	*	*	*	*	*	*	*	*
1935:				;
1936:				;  MOTOR	Start floppy  drive motor
1937:				;
1938:				;  This routine starts the target motor by executing a read address
1939:				;  command.  The xTRK, xSEC, and xDAT registers of the 1770 must be
1940:				;  saved as the read address command alters their contents.  After
1941:				;  the read address command, we have 2 seconds (10 index pulses) to
1942:				;  execute the next command before the motor shuts off.
1943:				;
1944:				;	*	*	*	*	*	*	*	*
1945:     -	E8BF          	MOTOR:
1946: 5892+11	E8BF  F5      		PUSH	AF		; save command
1947: 5903+11	E8C0  DBC4    		IN	A,(STAT)	; Check motor on bit
1948: 5914+4	E8C2  17      		RLA			; .
1949: 5918+7+5	E8C3  382E    		JR	C,MOTOROK	; Motor already on ...
1950: 5925+11	E8C5  E5      		PUSH	HL		; Save buffer pointer
1951: 5936+11	E8C6  DBC5    		IN	A,(RTRK)	; Save 1770 trk, sec, & dta regs
1952: 5947+4	E8C8  47      		LD	B,A		; .
1953: 5951+11	E8C9  DBC6    		IN	A,(RSEC)	; .
1954: 5962+4	E8CB  4F      		LD	C,A		; .
1955: 5966+11	E8CC  DBC7    		IN	A,(RDAT)	; .
1956: 5977+4	E8CE  57      		LD	D,A		; .
1957: 5981+17	E8CF  CDF5E8  		CALL	DWAIT		; Wait for the 1770 to get ready
1958: 5998+4	E8D2  AF      		XOR	A		; Setup seek to same track cmd
1959: 6002+11	E8D3  D3C1    		OUT	(WTRK),A	; .
1960: 6013+11	E8D5  D3C3    		OUT	(WDAT),A	; .
1961: 6024+7	E8D7  3E18    		LD	A,FSEEKNV	; .  (seek, no verify)
1962: 6031+11	E8D9  D3C0    		OUT	(CMND),A	; Send the cmd
1963:				
1964: 6042+11	E8DB  C5      		PUSH	BC		; Save BC reg for wait cmd
1965: 6053+7	E8DC  3E04    		LD	A,4		; Wait 4 * 250ms = 1 second
1966:     -	E8DE          	WAITMORE:
1967: 6060+11	E8DE  F5      		PUSH	AF		; Wait 250ms
1968: 6071+7	E8DF  3EFA    		LD	A,250		; .
1969: 6078+17	E8E1  CDEDE9  		CALL	WAIT		; .
1970: 6095+10	E8E4  F1      		POP	AF		; .
1971: 6105+4	E8E5  3D      		DEC	A		; More waiting?
1972: 6109+7+5	E8E6  20F6    		JR	NZ,WAITMORE
1973: 6116+10	E8E8  C1      		POP	BC		; Get BC reg back
1974:				
1975: 6126+4	E8E9  7A      		LD	A,D		; Restore 1770 registers
1976: 6130+11	E8EA  D3C3    		OUT	(WDAT),A	; .
1977: 6141+4	E8EC  79      		LD	A,C		; .
1978: 6145+11	E8ED  D3C2    		OUT	(WSEC),A	; .
1979: 6156+4	E8EF  78      		LD	A,B		; .
1980: 6160+11	E8F0  D3C1    		OUT	(WTRK),A	; .
1981: 6171+10	E8F2  E1      		POP	HL		; restore buffer pointer
1982:				
1983:     -	E8F3          	MOTOROK:
1984: 6181+10	E8F3  F1      		POP	AF		; Get command back
1985: 6191+10	E8F4  C9      		RET			; and return
1986:				
1987:				;	*	*	*	*	*	*	*	*
1988:				;
1989:				;  DWAIT	Wait for permission to write a register
1990:				;
1991:				;  This routine will wait up to 5 seconds for permission to write
1992:				;  to one of the FDC registers.  After 5 seconds, a FORCE INTERRUPT
1993:				;  command will be issued to the FDC.
1994:				;
1995:				;	*	*	*	*	*	*	*	*
1996:     -	E8F5          	DWAIT:
1997: 6201+10	E8F5  2152F3  		LD	HL,TIMEOUT	; Point to timeout location
1998: 6211+10	E8F8  3606    		LD	(HL),6		; Set 6 major loops
1999:				
2000: 6221+11	E8FA  DBC4    	DLOOP:	IN	A,(STAT)	; Get FDC status
2001: 6232+8	E8FC  CB47    		BIT	0,A		; Test bit 0 (BUSY), return with
2002: 6240+5+6	E8FE  C8      		RET	Z		; .  zero status if busy non-active
2003: 6245+6	E8FF  2B      		DEC	HL		; See if enough minor loops
2004: 6251+4	E900  7C      		LD	A,H		; .  (Approx 58,000 times)
2005: 6255+4	E901  B5      		OR	L		; .
2006: 6259+7+5	E902  20F6    		JR	NZ,DLOOP	; Not done with minor loop
2007:				
2008: 6266+10	E904  2152F3  		LD	HL,TIMEOUT	; Decrement major loop counter
2009: 6276+11	E907  35      		DEC	(HL)		; .  (6 times)
2010: 6287+7+5	E908  20F0    		JR	NZ,DLOOP	; .
2011: 6294+7	E90A  3ED0    		LD	A,0D0H		; Give up on waiting; issue a FORCED
2012: 6301+11	E90C  D3C0    		OUT	(CMND),A	; .  INTERRUPT to the FDC
2013: 6312+4	E90E  AF      		XOR	A		; Set A to 0FFH and status to NZ
2014: 6316+4	E90F  3D      		DEC	A		; .
2015: 6320+10	E910  C9      		RET			; Return to caller
2016:				
2017:				;	*	*	*	*	*	*	*	*
2018:				;
2019:				;  RESTORE	Restore a floppy drive to track 00
2020:				;
2021:				;  This routine issues a re-zero command to the 1770 which causes
2022:				;  the drive indicated by LOGDSK to slowly find its way back to 
2023:				;  the track zero (00) sensor.
2024:				;
2025:				;	*	*	*	*	*	*	*	*
2026:     -	E911          	RESTORE:			; Restore the disk head to track 00
2027: 6330+17	E911  CDF5E8  		CALL	DWAIT		; Wait for the 1770 to be ready
2028: 6347+5+6	E914  C0      		RET	NZ		; Return to caller if timeout
2029: 6352+17	E915  CD93E9  		CALL	GETSTEP		; Get the step rate for this drive
2030: 6369+7	E918  F608    		OR	FRESTOR		; Add restore command to step rate
2031: 6376+17	E91A  CDB4E8  		CALL	OUTCMD		; Send the cmd to the 1770
2032: 6393+17	E91D  CDF5E8  		CALL	DWAIT		; Wait for the cmd to finish
2033: 6410+7	E920  3E32    		LD	A,50		; Wait 50 ms for the drive to settle
2034: 6417+17	E922  CDEDE9  		CALL	WAIT		; .
2035: 6434+17	E925  CDB5E9  		CALL	MAPTRK		; Set this drive's last track
2036: 6451+10	E928  3600    		LD	(HL),0		; .  to track 00
2037:				
2038:     -	E92A          	NEXT$BLIP:
2039: 6461+7	E92A  3EC8    		LD	A,FRDADDR	; Send the READ ADDRESS cmd to the
2040: 6468+17	E92C  CDB4E8  		CALL	OUTCMD		; .  FDC and see if we get anything
2041: 6485+17	E92F  CDF5E8  		CALL	DWAIT		; Return if cmd finished (implies
2042:				
2043: 6502+5+6	E932  C8      		RET	Z		; .  both disk & drive present)
2044: 6507+7	E933  0E07    		LD	C,BELL		; Beep if no disk
2045: 6514+17	E935  CDA8EA  		CALL	CONOUT1		; .
2046: 6531+17	E938  CD84EA  		CALL	CONST1		; Check console status
2047: 6548+10+7	E93B  C494EA  		CALL	NZ,CONIN1	; Get char if one is there
2048: 6558+7	E93E  FE03    		CP	CTRLC		; Was the char a ctrl-C?
2049: 6565+7+5	E940  2804    		JR	Z,UABORT	; Yes, abort with error
2050: 6572+7	E942  FE1B    		CP	ESC		; Was the char an ESC?
2051: 6579+7+5	E944  20E4    		JR	NZ,NEXT$BLIP	; No, try again
2052:     -	E946          	UABORT:
2053: 6586+4	E946  AF      		XOR	A		; Return with error
2054: 6590+4	E947  3D      		DEC	A		; .
2055: 6594+10	E948  C9      		RET			; .
2056:				
2057:				;	*	*	*	*	*	*	*	*
2058:				;
2059:				;  SEEK		Seek to track (floppy only)
2060:				;
2061:				;  Moves the floppy head to the track indicated by CPMTRK if not
2062:				;  already there.
2063:				;
2064:				;	*	*	*	*	*	*	*	*
2065:     -	E949          	SEEK:
2066: 6604+17	E949  CDBFE8  		CALL	MOTOR		; Make sure the motor is on
2067: 6621+17	E94C  CD41EA  		CALL	GETTRK		; Get track we want
2068: 6638+11	E94F  F5      		PUSH	AF		; Save track #
2069: 6649+17	E950  CDC7E9  		CALL	SETUP		; Set up unit and real side
2070: 6666+10	E953  F1      		POP	AF		; Get track # back
2071: 6676+17	E954  CDA8E9  		CALL	MAPTYPE		; Check double step bit
2072: 6693+12	E957  CB76    		BIT	6,(HL)		; .
2073: 6705+7+5	E959  2801    		JR	Z,NODS1		; Skip double step if bit clear
2074: 6712+4	E95B  87      		ADD	A,A		; Otherwise multiply by 2
2075:     -	E95C          	NODS1:	
2076: 6716+11	E95C  D3C3    		OUT	(WDAT),A	; Tell the 1770 where we want to go
2077:				
2078: 6727+17	E95E  CDB5E9  		CALL	MAPTRK		; Get the current track #
2079: 6744+7	E961  7E      		LD	A,(HL)		; .
2080: 6751+17	E962  CDA8E9  		CALL	MAPTYPE		; Check double step bit
2081: 6768+12	E965  CB76    		BIT	6,(HL)		; .
2082: 6780+7+5	E967  2801    		JR	Z,NODS2		; Skip double step if bit clear
2083: 6787+4	E969  87      		ADD	A,A		; Otherwise multiply by 2
2084:     -	E96A          	NODS2:
2085: 6791+11	E96A  D3C1    		OUT	(WTRK),A	; Tell the 1770 where we are
2086: 6802+17	E96C  CD93E9  		CALL	GETSTEP		; Get the step rate for this drive
2087: 6819+7	E96F  F618    		OR	FSEEKNV		; OR in seek without verify cmd
2088: 6826+11	E971  F5      		PUSH	AF		; Save A reg as DWAIT destroys it
2089: 6837+17	E972  CDF5E8  		CALL	DWAIT		; Wait until 1770 is ready
2090: 6854+10	E975  F1      		POP	AF		; Get A reg back (1770 cmd)
2091: 6864+17	E976  CDB4E8  		CALL	OUTCMD		; Send the cmd
2092: 6881+17	E979  CDF5E8  		CALL	DWAIT		; Wait for the cmd to finish
2093: 6898+7	E97C  E618    		AND	18H		; Isolate possible failures
2094: 6905+5+6	E97E  C0      		RET	NZ		; Seek failed, return error
2095:				
2096: 6910+7	E97F  3EC8    		LD	A,FRDADDR	; Read current track info
2097: 6917+10	E981  2143F3  		LD	HL,IDSAVE	; .
2098: 6927+17	E984  CD82E8  		CALL	RDATA		; .
2099: 6944+17	E987  CDB5E9  		CALL	MAPTRK		; Get ptr to track save area
2100: 6961+17	E98A  CD41EA  		CALL	GETTRK		; Get track we were seeking
2101: 6978+4	E98D  47      		LD	B,A		; Save it for a moment
2102: 6982+11	E98E  DBC6    		IN	A,(RSEC)	; Get track # from the FDC
2103: 6993+4	E990  B8      		CP	B		; Compare to what we wanted
2104: 6997+7	E991  77      		LD	(HL),A		; Save FDC track # in either case
2105: 7004+10	E992  C9      		RET			; Z=ok, NZ=error
2106:				
2107:				;	*	*	*	*	*	*	*	*
2108:				;
2109:				;  GETSTEP	Get the step rate for a particular drive
2110:				;
2111:				;  Sets the HL register pair to the location which contains the 
2112:				;  step rate for the drive indicated by PHYDRV, and returns the
2113:				;  actual step bits in the A register.
2114:				;
2115:				;  Registers modified:	A, PSW, DE, HL
2116:				;
2117:				;	*	*	*	*	*	*	*	*
2118:     -	E993          	GETSTEP:
2119: 7014+13	E993  3A31F3  		LD	A,(PHYDRV)	; Get physical drive unit
2120: 7027+7	E996  FE04    		CP	04		; E-disk?
2121: 7034+7+5	E998  2003    		JR	NZ,GET$AD	; No,  use normal unit #
2122: 7041+13	E99A  3A69E3  		LD	A,(EDSD)	; Yes, use E-disk unit #
2123:     -	E99D          	GET$AD:
2124: 7054+4	E99D  5F      		LD	E,A		; Get step rate from table
2125: 7058+7	E99E  1600    		LD	D,0		; .  (based on physical unit)
2126: 7065+10	E9A0  215DE2  		LD	HL,STPRAT	; .
2127: 7075+11	E9A3  19      		ADD	HL,DE		; .
2128: 7086+7	E9A4  7E      		LD	A,(HL)		; .
2129: 7093+7	E9A5  E603    		AND	03H		; Mask off junk, just in case
2130: 7100+10	E9A7  C9      		RET			; And return data in A and HL
2131:				
2132:				;	*	*	*	*	*	*	*	*
2133:				;
2134:				;  MAPTYPE	Get pointer to physical type byte
2135:				;
2136:				;  Sets the HL register pair to the location which contains the 
2137:				;  type byte for the physical drive indicated by PHYDRV.
2138:				;
2139:				;  The format of the physical type bytes can be found in the 
2140:				;  description of DRIVE$TYPES at BIOS+070H.
2141:				;
2142:				;  Registers modified:	DE, HL
2143:				;
2144:				;	*	*	*	*	*	*	*	*
2145:     -	E9A8          	MAPTYPE:
2146: 7110+11	E9A8  F5      		PUSH	AF		; Save entry A reg and flags
2147: 7121+13	E9A9  3A31F3  		LD	A,(PHYDRV)	; Get physical drive unit
2148: 7134+4	E9AC  5F      		LD	E,A		; Compute pointer to physical
2149: 7138+7	E9AD  1600    		LD	D,0		; .  type byte
2150: 7145+10	E9AF  2170E2  		LD	HL,DRIVE$TYPES	; .
2151: 7155+11	E9B2  19      		ADD	HL,DE		; .
2152: 7166+10	E9B3  F1      		POP	AF		; Get A reg and flags back
2153: 7176+10	E9B4  C9      		RET			; And return with ptr in HL
2154:				
2155:				;	*	*	*	*	*	*	*	*
2156:				;
2157:				;  MAPTRK	Return pointer to current track
2158:				;
2159:				;  Sets the HL register pair to the location which contains the 
2160:				;  current track for the drive indicated by PHYDRV.
2161:				;
2162:				;  Registers modified:	A, PSW, DE, HL
2163:				;
2164:				;	*	*	*	*	*	*	*	*
2165:     -	E9B5          	MAPTRK:
2166: 7186+13	E9B5  3A31F3  		LD	A,(PHYDRV)	; Get physical drive unit
2167: 7199+7	E9B8  FE04    		CP	04		; E-disk?
2168: 7206+7+5	E9BA  2003    		JR	NZ,MAP$AD	; No,  use normal unit #
2169: 7213+13	E9BC  3A69E3  		LD	A,(EDSD)	; Yes, use E-disk unit #
2170:     -	E9BF          	MAP$AD:
2171: 7226+4	E9BF  5F      		LD	E,A		; Compute ptr to current track
2172: 7230+7	E9C0  1600    		LD	D,0		; .
2173: 7237+10	E9C2  2149F3  		LD	HL,LTRACK	; .
2174: 7247+11	E9C5  19      		ADD	HL,DE		; .
2175: 7258+10	E9C6  C9      		RET			; Return with pointer in HL
2176:				
2177:				;	*	*	*	*	*	*	*	*
2178:				;
2179:				;  SETUP	Setup the system control register for a drive select
2180:				;
2181:				;  This routine writes to the system control port register at I/O
2182:				;  00H, causing the associated drive to be selected, along with
2183:				;  the head select signal line.
2184:				;
2185:				;  NOTE:  This routine always turns the internal system rom OFF,
2186:				;  without any regard for those who just may have the rom enabled
2187:				;  prior to entry.
2188:				;
2189:				;  NOTE:  This routine modifies all registers
2190:				;
2191:				;	*	*	*	*	*	*	*	*
2192:     -	E9C7          	SETUP:
2193: 7268+17	E9C7  CDA8E9  		CALL	MAPTYPE		; Get pointer to drive type byte
2194: 7285+7	E9CA  7E      		LD	A,(HL)		; Get byte
2195: 7292+7	E9CB  F640    		OR	040H		; Turn off EPROM
2196: 7299+10	E9CD  2151F3  		LD	HL,HSTSID	; Point to side select
2197: 7309+7	E9D0  B6      		OR	(HL)		; Include proper side select
2198:				
2199: 7316+4	E9D1  4F      		LD	C,A		; Save control byte
2200: 7320+7	E9D2  E68F    		AND	10001111B	; Mask out eprom, density, & side
2201: 7327+10	E9D4  2154F3  		LD	HL,CHGDSK	; Compare with previous results
2202: 7337+7	E9D7  BE      		CP	(HL)		; .
2203: 7344+7	E9D8  77      		LD	(HL),A		; .  (save this result anyway)
2204: 7351+7+5	E9D9  280E    		JR	Z,SETUP2	; Skip split & delay if same
2205:				
2206: 7358+4	E9DB  79      		LD	A,C		; Get control byte back
2207: 7362+7	E9DC  E6F0    		AND	0F0H		; Mask out drive bits
2208: 7369+11	E9DE  D300    		OUT	(CONT),A	; Send speed only to control port
2209: 7380+4	E9E0  79      		LD	A,C		; Get control byte back
2210: 7384+11	E9E1  D300    		OUT	(CONT),A	; Send full byte to the control port
2211:				
2212: 7395+7	E9E3  3E23    		LD	A,HLDELAY	; Delay HLDELAY ms (usually 30ms)
2213: 7402+17	E9E5  CDEDE9  		CALL	WAIT		; .
2214: 7419+10	E9E8  C9      		RET
2215:     -	E9E9          	SETUP2:
2216: 7429+4	E9E9  79      		LD	A,C		; Get control byte back
2217: 7433+11	E9EA  D300    		OUT	(CONT),A	; Send to control port
2218: 7444+10	E9EC  C9      		RET
2219:				
2220:				;	*	*	*	*	*	*	*	*
2221:				;
2222:				;  WAIT		Wait "A" ms
2223:				;
2224:				;  Modifies:	A,PSW  (A = 0, Z flag set)
2225:				;
2226:				;	*	*	*	*	*	*	*	*
2227:     -	E9ED          	WAIT:
2228: 7454+11	E9ED  C5      		PUSH	BC
2229:     -	E9EE          	WAIT1:
2230: 7465+7	E9EE  06C7    		LD	B,199
2231: 7472+7	E9F0  BE      	WAIT2:	CP	(HL)
2232: 7479+8+5	E9F1  10FD    		DJNZ	WAIT2
2233: 7487+4	E9F3  3D      		DEC	A
2234: 7491+7+5	E9F4  20F8    		JR	NZ,WAIT1
2235: 7498+10	E9F6  C1      		POP	BC
2236: 7508+10	E9F7  C9      		RET
2237:				
2238:				;	*	*	*	*	*	*	*	*
2239:				;
2240:				;  GETTYPE	Get the type byte and ptr for a drive unit
2241:				;
2242:				;  Returns the current disk type identifier in the A reg, and the
2243:				;  address of the entry in the HL reg pair.
2244:				;
2245:				;  See PHYTAB (driver table) for the definition of the type byte.
2246:				;
2247:				;  Modifies:	A, DE, HL
2248:				;
2249:				;	*	*	*	*	*	*	*	*
2250:     -	E9F8          	GETTYPE:
2251: 7518+13	E9F8  3A30F3  		LD	A,(LOGDSK)	; Use logical disk entry value
2252: 7531+17	E9FB  CD05E4  		CALL	PAGET		; Get ptr to table entry
2253: 7548+6	E9FE  23      		INC	HL		; Type byte is at table+2
2254: 7554+6	E9FF  23      		INC	HL		; .
2255: 7560+7	EA00  7E      		LD	A,(HL)		; Get type byte
2256: 7567+10	EA01  C9      		RET			; Return type in A, ptr in HL
2257:				
2258:     -	EA02          	GETSEC:				; CONVERT LOGICAL SECTOR TO PHYSICAL SECTOR
2259: 7577+11	EA02  E5      		PUSH	HL
2260: 7588+17	EA03  CDF8E9  		CALL	GETTYPE
2261: 7605+7	EA06  E603    		AND	3		; 128 BYTE SECTOR?
2262: 7612+13	EA08  3A17EF  		LD	A,(CPMSEC)	; NOPE, DO MAPPING
2263: 7625+7+5	EA0B  2803    		JR	Z,GOTSDS
2264: 7632+13	EA0D  3A13EF  		LD	A,(HSTSEC)
2265:				
2266: 7645+11	EA10  F5      	GOTSDS:	PUSH	AF		; SAVE SECTOR
2267: 7656+17	EA11  CD38E6  		CALL	GETDPT		; FETCH POINTER TO XLT TABLE
2268: 7673+7	EA14  5E      		LD	E,(HL)
2269: 7680+6	EA15  23      		INC	HL
2270: 7686+7	EA16  56      		LD	D,(HL)
2271: 7693+4	EA17  EB      		EX	DE,HL		; TRANSLATE TABLE NOW IN HL
2272: 7697+10	EA18  F1      		POP	AF		; RESTORE DESIRED SECTOR
2273: 7707+4	EA19  5F      		LD	E,A
2274: 7711+7	EA1A  1600    		LD	D,0
2275: 7718+11	EA1C  19      		ADD	HL,DE
2276: 7729+7	EA1D  7E      		LD	A,(HL)		; GET PHYSICAL SECTOR FROM TABLE
2277: 7736+4	EA1E  5F      		LD	E,A		; SAVE IT
2278: 7740+13	EA1F  3A31F3  		LD	A,(PHYDRV)
2279: 7753+7	EA22  FE04    		CP	04H		; WAS IT E DISK?
2280: 7760+7+5	EA24  200B    		JR	NZ,GSEXIT	; NO, THEN NO ADJUST
2281: 7767+13	EA26  3A51F3  		LD	A,(HSTSID)	; WHICH SIDE?
2282: 7780+4	EA29  B7      		OR	A
2283: 7784+7+5	EA2A  2805    		JR	Z,GSEXIT
2284: 7791+13	EA2C  3A5CF3  		LD	A,(ESECADJ)	; ELSE GET ADJUSTMENT
2285: 7804+4	EA2F  83      		ADD	A,E
2286: 7808+4	EA30  5F      		LD	E,A		; PUT IT BACK FOR MOVE
2287:				
2288: 7812+4	EA31  7B      	GSEXIT:	LD	A,E		; MOVE REAL SECTOR TO A
2289: 7816+10	EA32  E1      		POP	HL
2290: 7826+10	EA33  C9      		RET
2291:				
2292: 7836+17	EA34  CDF8E9  	GETBUF:	CALL	GETTYPE		; GET THE DMA ADDRESS
2293: 7853+7	EA37  E603    		AND	3		; 128 BYTE SECTORS?
2294: 7860+10	EA39  212AEF  		LD	HL,HSTBUF	; USED FOR DD
2295: 7870+5+6	EA3C  C0      		RET	NZ
2296: 7875+16	EA3D  2A28EF  		LD	HL,(DMAADR)	; ELSE USE REAL DMA ADDRESS...
2297: 7891+10	EA40  C9      		RET
2298:				
2299:				;	*	*	*	*	*	*	*	*
2300:				;
2301:				;  GETTRK	Convert logical to physical track
2302:				;
2303:				;  This routine converts the logical track stored in CPMTRK to
2304:				;  the actual physical track and side to be used.
2305:				;
2306:				;  The physical track is returned in the A register, and the side
2307:				;  to be used is returned in HSTSID.
2308:				;
2309:				;	*	*	*	*	*	*	*	*
2310: 7901+11	EA41  E5      	GETTRK:	PUSH	HL		; Save HL register
2311: 7912+17	EA42  CDF8E9  		CALL	GETTYPE		; Get the type byte for this disk
2312: 7929+10	EA45  2151F3  		LD	HL,HSTSID	; Point to the side flag
2313: 7939+4	EA48  17      		RLA			; Determine SS or DS
2314: 7943+4	EA49  17      		RLA			; .
2315: 7947+13	EA4A  3A15EF  		LD	A,(CPMTRK)	; Get track #
2316: 7960+7+5	EA4D  3007    		JR	NC,GETTRK1	; Not DS -- leave track alone
2317: 7967+4	EA4F  1F      		RRA			; Divide track by 2 to get side
2318: 7971+7+5	EA50  3004    		JR	NC,GETTRK1	; No carry means side 0
2319: 7978+10	EA52  3610    		LD	(HL),10H	; Indicate side 1
2320: 7988+12	EA54  1802    		JR	GETTRK2		; And finish up
2321:     -	EA56          	GETTRK1:
2322: 8000+10	EA56  3600    		LD	(HL),0		; Indicate side 0
2323:     -	EA58          	GETTRK2:
2324: 8010+10	EA58  E1      		POP	HL		; Get HL register back
2325: 8020+7	EA59  E67F    		AND	07FH		; Mask high bit, just in case
2326: 8027+10	EA5B  C9      		RET			; ... and return
2327:				
2328:				;	LOGICAL DEVICE	  PHYSICAL DEVICE ASSIGNMENTS
2329:				;	--------------	  ---------------------------
2330:				;	CON:		  CRT: OR TTY:
2331:				;	READER: 	  TTY:
2332:				;	PUNCH:		  TTY:
2333:				;	LIST:		  CRT: OR TTY: OR LPT:
2334:				
2335:     -	EA5C          	CONPEEK:
2336: 8037+20	EA5C  ED7311ED		LD	(OLDSTK),SP
2337: 8057+10	EA60  310FED  		LD	SP,LOCSTK
2338: 8067+13	EA63  3A0300  		LD	A,(IOBYTE)
2339: 8080+7	EA66  E603    		AND	11B
2340: 8087+7+5	EA68  2809    		JR	Z,TTYPEEK
2341:     -	EA6A          	CRTPEEK:
2342: 8094+17	EA6A  CDC5EA  		CALL	CRTIST		; READY?
2343: 8111+5+6	EA6D  C8      		RET	Z		; NO, return 0
2344: 8116+16	EA6E  2A18ED  		LD	HL,(KEYST)	; first character position
2345: 8132+12	EA71  1807    		JR	PEEKCHR
2346:     -	EA73          	TTYPEEK:
2347: 8144+17	EA73  CDFEEA  		CALL	TTYIST
2348: 8161+5+6	EA76  C8      		RET	Z
2349: 8166+16	EA77  2A1DED  		LD	HL,(MdmIst)	; point to start of modem queue
2350:     -	EA7A          	PEEKCHR:
2351: 8182+7	EA7A  7E      		LD	A,(HL)		; get character
2352: 8189+4	EA7B  B7      		OR	A
2353: 8193+10	EA7C  C9      		RET
2354:					
2355:				
2356:     -	EA7D          	CONST:				; CONSOLE STATUS, RETURNS 0FFH IF CHARACTER READY, ELSE 00H
2357: 8203+20	EA7D  ED7311ED		LD	(OLDSTK),SP	; ld(oldstk),sp - save old stack
2358: 8223+10	EA81  310FED  		LD	SP,LOCSTK	; set local stack
2359:     -	EA84          	CONST1:	
2360: 8233+13	EA84  3A0300  		LD	A,(IOBYTE)	; CHECK DEVICE ASSIGNMENT
2361: 8246+7	EA87  E603    		AND	11B		; KEEP CON BITS ONLY
2362: 8253+7+5	EA89  2873    		JR	Z,TTYIST	; check appropriate input status
2363: 8260+12	EA8B  1838    		JR	CRTIST		; no third or fourth choices
2364:				
2365:     -	EA8D          	CONIN:				; CONSOLE CHARACTER INTO REGISTER A
2366: 8272+20	EA8D  ED7311ED		LD	(OLDSTK),SP	; save old stack
2367: 8292+10	EA91  310FED  		LD	SP,LOCSTK	; local stack
2368:     -	EA94          	CONIN1:
2369: 8302+13	EA94  3A0300  		LD	A,(IOBYTE)
2370: 8315+7	EA97  E603    		AND	11B
2371: 8322+7+5	EA99  203B    		JR	nz,CRTIN	; do crtin
2372: 8329+17	EA9B  CD2BEB  		CALL	TTYIN		; do ttyin
2373: 8346+7	EA9E  E67F    		AND	07FH		; strip parity bit from console input
2374: 8353+10	EAA0  C9      		RET
2375:					
2376:				
2377:     -	EAA1          	CONOUT:				; CONSOLE CHARACTER OUTPUT FROM REGISTER C
2378: 8363+20	EAA1  ED7311ED		LD	(OLDSTK),SP	; ld(oldstk),sp - save old stack
2379: 8383+10	EAA5  310FED  		LD	SP,LOCSTK	; set local stack
2380:     -	EAA8          	CONOUT1:
2381: 8393+13	EAA8  3A0300  		LD	A,(IOBYTE)
2382: 8406+7	EAAB  E603    		AND	11B
2383: 8413+7+5	EAAD  2857    		JR	Z,TTYOUT	; out tty
2384: 8420+12	EAAF  181C    		JR	CRTOUT		; out crt
2385:					
2386:     -	EAB1          	CRTOST:				; CRT OUTPUT STATUS
2387: 8432+11	EAB1  DB84    		in	a,(SIOCPA)	; RETURN 0FFH IF READY TO SEND, 00H IF NOT
2388: 8443+7	EAB3  E604    		and	TBE
2389: 8450+5+6	EAB5  C8      		ret	z		; transmitter buffer not empty
2390: 8455+13	EAB6  3A6CE2  		LD	A,(HSA)		; see if cts h/s required
2391: 8468+4	EAB9  B7      		OR	A
2392: 8472+7+5	EABA  2806    		JR	Z,CRTRDY	; if zero, no handshake needed
2393: 8479+13	EABC  3A4FEC  		ld	a,(SioAstatus)
2394: 8492+7	EABF  E620    		AND	CTS
2395: 8499+5+6	EAC1  C8      		RET	Z		; CTS NOT ACTIVE
2396: 8504+7	EAC2  F6FF    	CRTRDY:	OR	255		; SHOW READY TO END
2397: 8511+10	EAC4  C9      		RET
2398:				
2399:     -	EAC5          	CRTIST:				; CRT INPUT STATUS, RETURN 0FFH IF DATA READY, 00H IF NOT
2400: 8521+13	EAC5  3A1CED  		ld	a,(keylen)
2401: 8534+4	EAC8  B7      		or	a
2402: 8538+5+6	EAC9  C8      		ret	z		; if same exit, nothing in buffer
2403: 8543+7	EACA  F6FF    		or	0ffh		; show buffer has character
2404: 8550+10	EACC  C9      		RET
2405:				
2406:     -	EACD          	CRTOUT:
2407: 8560+17	EACD  CDB1EA  		CALL	CRTOST		; OK TO SEND?
2408: 8577+7+5	EAD0  28FB    		JR	Z,CRTOUT	; NO WAIT
2409: 8584+4	EAD2  79      		LD	A,C		; CHARACTER TO REGISTER A
2410: 8588+11	EAD3  D380    		OUT	(SIODPA),A
2411: 8599+10	EAD5  C9      		RET
2412:				
2413:     -	EAD6          	CRTIN:
2414: 8609+17	EAD6  CDC5EA  		CALL	CRTIST		; READY?
2415: 8626+7+5	EAD9  28FB    		JR	Z,CRTIN		; NO, WAIT
2416: 8633+4	EADB  F3      		di			; leave me alone while I'm playing with
2417: 8637+10	EADC  211CED  		ld	hl,keylen	; the queue
2418: 8647+11	EADF  35      		dec	(hl)		; dec # of chars in keyboard queue
2419: 8658+16	EAE0  2A18ED  		LD	HL,(KEYST)	; first character position
2420: 8674+7	EAE3  7E      		ld	a,(hl)		; get character
2421: 8681+6	EAE4  23      		INC	HL
2422: 8687+16	EAE5  2218ED  		LD	(KEYST),HL	; next character
2423: 8703+7+5	EAE8  2009    		JR	NZ,krex		; 
2424: 8710+10	EAEA  215DF3  		LD	HL,KEYBUF	; reset buffer start and end
2425: 8720+16	EAED  2218ED  		LD	(KEYST),HL
2426: 8736+16	EAF0  221AED  		LD	(KEYEND),HL
2427: 8752+4	EAF3  FB      	krex:	ei			; ok, i'm done
2428: 8756+10	EAF4  C9      		RET
2429:				;
2430:				; tty output status, return 0ffh if ready to send, 00h if not
2431:				;
2432:     -	EAF5          	TTYOST:
2433: 8766+13	EAF5  3A26ED  		ld	a,(MdmOlen)	; get current size of output buffer
2434: 8779+7	EAF8  D6AB    		sub	MdmOsize+1	; compare to maximum buffer size + 1 char for
2435:								; transmit buffer
2436: 8786+5+6	EAFA  C8      		ret	z		; buffer is full, not ready to send
2437: 8791+7	EAFB  F6FF    		or	0ffh		; some left, ok to send
2438: 8798+10	EAFD  C9      		ret
2439:				
2440:     -	EAFE          	TTYIST:				; TTY INPUT STATUS, RETURN 0FFH IF DATA READY, 00H IF NOT
2441: 8808+13	EAFE  3A21ED  		ld	a,(MdmIlen)
2442: 8821+4	EB01  B7      		or	a
2443: 8825+5+6	EB02  C8      		ret	z
2444: 8830+7	EB03  F6FF    		or	0ffh
2445: 8837+10	EB05  C9      		RET
2446:				
2447:     -	EB06          	PUNCH:				; PUNCH CHARACTER FROM REGISTER C
2448:     -	EB06          	TTYOUT:
2449: 8847+17	EB06  CDF5EA  		CALL	TTYOST		; OK TO SEND?
2450: 8864+7+5	EB09  28FB    		JR	Z,TTYOUT	; No wait
2451: 8871+10	EB0B  2126ED  		ld	hl,MdmOlen	; any chars outstanding (either on queue
2452: 8881+4	EB0E  F3      		di			; or in transmit buffer)?
2453: 8885+7	EB0F  7E      		ld	a,(hl)
2454: 8892+11	EB10  34      		inc	(hl)		; bump # chars outstanding
2455: 8903+4	EB11  B7      		or	a
2456: 8907+7+5	EB12  2005    		jr	nz,punch1	; yes, place in queue
2457: 8914+4	EB14  79      		LD	A,C		; CHARACTER TO REGISTER A
2458: 8918+11	EB15  D388    		OUT	(SIODPB),A
2459: 8929+4	EB17  FB      		ei
2460: 8933+10	EB18  C9      		RET
2461: 8943+16	EB19  2A24ED  	punch1:	ld	hl,(MdmOend)
2462: 8959+7	EB1C  71      		ld	(hl),c		; add char to queue
2463: 8966+6	EB1D  23      		inc	hl		; increment to next empty position
2464: 8972+7	EB1E  3E47    		ld	a,MdmOstop
2465: 8979+4	EB20  BD      		cp	l		; check for wrap at end of buffer
2466: 8983+7+5	EB21  2003    		jr	nz,punch2
2467: 8990+10	EB23  219DF3  		ld	hl,MdmObuf	; wrap to start of buffer
2468: 9000+16	EB26  2224ED  	punch2:	ld	(MdmOend),hl	; update tail pointer
2469: 9016+4	EB29  FB      		ei
2470: 9020+10	EB2A  C9      		ret	
2471:				
2472:     -	EB2B          	READER:				; READ CHARACTER INTO REGISTER A FROM READER DEVICE
2473:     -	EB2B          	TTYIN:
2474: 9030+17	EB2B  CDFEEA  		call	TTYIST
2475: 9047+7+5	EB2E  28FB    		jr	z,TTYIN
2476: 9054+4	EB30  F3      		di
2477: 9058+16	EB31  2A1DED  		ld	hl,(MdmIst)	; point to start of modem queue
2478: 9074+7	EB34  7E      		ld	a,(hl)		; get key from queue
2479: 9081+11	EB35  F5      		push	af		; and save it...
2480: 9092+6	EB36  23      		inc	hl		; point to next available key
2481: 9098+7	EB37  3EF1    		ld	a,MdmIstop
2482: 9105+4	EB39  BD      		cp	l		; check for wrap at end of buffer
2483: 9109+7+5	EB3A  2003    		jr	nz,ttyin1
2484: 9116+10	EB3C  2147F4  		ld	hl,MdmIbuf	; wrap to start of buffer
2485: 9126+16	EB3F  221DED  	ttyin1:	ld	(MdmIst),hl	; update head pointer
2486: 9142+10	EB42  2121ED  		ld	hl,MdmIlen
2487: 9152+11	EB45  35      		dec	(hl)		; decrement # keys in buffer
2488: 9163+7	EB46  7E      		ld	a,(hl)
2489: 9170+7	EB47  FE55    		cp	MdmIsize/2	; coming down from large buffer
2490: 9177+7+5	EB49  300D    		jr	nc,ttyin2	; no, no need to turn on RTS
2491: 9184+7	EB4B  3E05    		ld	a,5		; select SIO reg 5
2492: 9191+11	EB4D  D38C    		out	(SIOCPB),a
2493: 9202+10	EB4F  2159E2  		ld	hl,SIOBR5
2494: 9212+7	EB52  7E      		ld	a,(hl)		; get current reg 5 setting
2495: 9219+7	EB53  F602    		or	00000010b	; turn on RTS
2496: 9226+11	EB55  D38C    		out	(SIOCPB),a	; and update SIO
2497: 9237+7	EB57  77      		ld	(hl),a		; update current reg 5 setting
2498:     -	EB58          	ttyin2:
2499: 9244+4	EB58  FB      		ei
2500: 9248+10	EB59  F1      		pop	af		; restore key value
2501: 9258+10	EB5A  C9      		ret
2502:				;
2503:				; TTYBRK: send 300mS break to modem
2504:				;
2505:     -	EB5B          	TTYBRK:
2506: 9268+7	EB5B  3E05    		ld	a,5		; select register 5
2507: 9275+4	EB5D  F3      		di
2508: 9279+11	EB5E  D38C    		out	(SIOCPB),a
2509: 9290+10	EB60  2159E2  		ld	hl,SIOBR5
2510: 9300+7	EB63  3E10    		ld	a,00010000b	; set break bit on
2511: 9307+7	EB65  B6      		or	(hl)		; or in current settings
2512: 9314+7	EB66  77      		ld	(hl),a		; update current
2513: 9321+11	EB67  D38C    		out	(SIOCPB),a	; send break
2514: 9332+4	EB69  FB      		ei
2515: 9336+7	EB6A  0625    		ld	b,300/8		; # 8 mS transitions to look for
2516: 9343+11	EB6C  DB70    		in	a,(CTCA3)	; get 8mS counter value
2517: 9354+4	EB6E  4F      		ld	c,a
2518:     -	EB6F          	TTYBLP:
2519: 9358+11	EB6F  DB70    		in	a,(CTCA3)	; get current tick value
2520: 9369+4	EB71  B9      		cp	c		; changed?
2521: 9373+7+5	EB72  28FB    		jr	z,TTYBLP	; no, still on current tick
2522: 9380+4	EB74  4F      		ld	c,a		; 8mS passed, update tick value
2523: 9384+8+5	EB75  10F8    		djnz	TTYBLP
2524: 9392+4	EB77  F3      		di
2525: 9396+7	EB78  3E05    		ld	a,5
2526: 9403+11	EB7A  D38C    		out	(SIOCPB),a	; restore original reg5 in SIO/DART
2527: 9414+7	EB7C  3EEF    		ld	a,11101111b	; set break bit off
2528: 9421+7	EB7E  A6      		and	(hl)		; and off break bit
2529: 9428+7	EB7F  77      		ld	(hl),a		; update current setting
2530: 9435+11	EB80  D38C    		out	(SIOCPB),a
2531: 9446+4	EB82  FB      		ei
2532: 9450+10	EB83  C9      		ret
2533:     -	EB84          	LISTST:				; RETURN LIST STATUS, 0FFH IF READY, ELSE 00H
2534: 9460+20	EB84  ED7311ED		LD	(OLDSTK),SP	; ld(oldstk),sp - save old stack
2535: 9480+10	EB88  310FED  		LD	SP,LOCSTK	; local stack
2536: 9490+13	EB8B  3A0300  	LSTST1:	LD	A,(IOBYTE)	; CHECK DEVICE ASSIGNMENT
2537: 9503+7	EB8E  E6C0    		AND	11000000B	; KEEP LST BITS ONLY
2538: 9510+7+5	EB90  2003    		JR	NZ,LSTST2	; tty ?
2539: 9517+10	EB92  C3F5EA  		JP	TTYOST		; check tty output status
2540:				
2541: 9527+7	EB95  E640    	LSTST2:	AND	01000000B	; CRT?
2542: 9534+7+5	EB97  282B    		JR	Z,LPTST		; lpt
2543: 9541+10	EB99  C3B1EA  		JP	CRTOST		; crt
2544:				
2545:     -	EB9C          	LSTOUT:				; LIST CHARACTER OUTPUT FROM REGISTER C
2546: 9551+20	EB9C  ED7311ED		LD	(OLDSTK),SP	; ld(oldstk),sp - save old stack
2547: 9571+10	EBA0  310FED  		LD	SP,LOCSTK	; set stack pointer
2548:     -	EBA3          	LIST1:	
2549: 9581+17	EBA3  CD8BEB  		CALL	LSTST1		; WAIT TILL READY TO SEND
2550: 9598+7+5	EBA6  28FB    		JR	Z,LIST1
2551: 9605+13	EBA8  3A0300  		LD	A,(IOBYTE)	; CHECK DEVICE ASSIGNMENT
2552: 9618+7	EBAB  E6C0    		AND	11000000B	; KEEP LST BITS ONLY
2553: 9625+10	EBAD  CA06EB  		JP	Z,TTYOUT
2554: 9635+7	EBB0  FE40    		CP	01000000B
2555: 9642+10	EBB2  CACDEA  		JP	Z,CRTOUT
2556: 9652+12	EBB5  1800    		JR	LPTOUT		; no forth choice
2557:				
2558:     -	EBB7          	LPTOUT:				; PRINTER CHARACTER OUTPUT FROM REGISTER C
2559: 9664+17	EBB7  CDC4EB  		CALL	LPTST		; PRINTER READY?
2560: 9681+7+5	EBBA  28FB    		JR	Z,LPTOUT	; not ready, wait
2561: 9688+4	EBBC  79      		LD	A,C
2562: 9692+11	EBBD  D301    		OUT	(PIO1),A	; SET UP THE DATA
2563: 9703+11	EBBF  D302    		OUT	(STBSET),A	; SEND A DATA STROBE
2564: 9714+11	EBC1  D303    		OUT	(STBCLR),A	;  (DATA DOESN'T MATTER)
2565: 9725+10	EBC3  C9      		RET
2566:				
2567:     -	EBC4          	LPTST:				; RETURN LIST STATUS, 0FFH IF READY, ELSE 00H
2568: 9735+13	EBC4  3A76EC  		ld	a,(SioBstatus)	;
2569: 9748+7	EBC7  E610    		AND	PRTRDY		;
2570: 9755+5+6	EBC9  C8      		RET	Z		; NOT READY
2571: 9760+7	EBCA  F6FF    		OR	255		; SHOW READY
2572: 9767+10	EBCC  C9      		RET
2573:				
2574:				;
2575:				; special Rx condition on channel A
2576:				;
2577:     -	EBCD          	keyerr:
2578: 9777+11	EBCD  F5      		push	af
2579: 9788+7	EBCE  3E01    		ld	a,1		; read error register
2580: 9795+11	EBD0  D384    		out	(SIOCPA),a
2581: 9806+11	EBD2  DB84    		in	a,(SIOCPA)
2582: 9817+7	EBD4  3E30    		ld	a,30h		; reset errors
2583: 9824+11	EBD6  D384    		out	(SIOCPA),a
2584: 9835+11	EBD8  DB80    		in	a,(SIODPA)	; read bad char
2585: 9846+10	EBDA  F1      		pop	af
2586: 9856+4	EBDB  FB      		ei
2587: 9860+14	EBDC  ED4D    		reti
2588:				;
2589:				; special Rx condition on channel B
2590:				;
2591:     -	EBDE          	mdmerr:
2592: 9874+11	EBDE  F5      		push	af
2593: 9885+7	EBDF  3E01    		ld	a,1		; read error register
2594: 9892+11	EBE1  D38C    		out	(SIOCPB),a
2595: 9903+11	EBE3  DB8C    		in	a,(SIOCPB)
2596: 9914+7	EBE5  3E30    		ld	a,30h		; reset errors
2597: 9921+11	EBE7  D38C    		out	(SIOCPB),a
2598: 9932+11	EBE9  DB88    		in	a,(SIODPB)	; read bad char
2599: 9943+10	EBEB  F1      		pop	af
2600: 9953+4	EBEC  FB      		ei
2601: 9957+14	EBED  ED4D    		reti
2602:				;
2603:				; Keychk: keyboard input interrupt
2604:				;
2605:     -	EBEF          	KEYCHK:	
2606: 9971+11	EBEF  F5      		PUSH	AF
2607: 9982+11	EBF0  E5      		PUSH	HL		; save 'hl'
2608: 9993+16	EBF1  2A1AED  		LD	HL,(KEYEND)	; next character position in buffer
2609:10009+7	EBF4  3E9D    		LD	A,KEYSTOP	; get low byte of max addr
2610:10016+4	EBF6  BD      		CP	L		; see if end of buffer
2611:10020+11	EBF7  DB80    		IN	A,(SIODPA)	; get data
2612:10031+7+5	EBF9  280B    		JR	Z,KEYEXT	; no more buffer available
2613:10038+7	EBFB  E67F    		AND	7FH		; strip parity
2614:10045+7	EBFD  77      		LD	(HL),A		; save char
2615:10052+6	EBFE  23      		INC	HL		; next position in buffer
2616:10058+16	EBFF  221AED  		LD	(KEYEND),HL	; save new pointer
2617:10074+10	EC02  211CED  		ld	hl,keylen	; bump # of keys in queue
2618:10084+11	EC05  34      		inc	(hl)
2619:10095+10	EC06  E1      	KEYEXT:	POP	HL
2620:10105+10	EC07  F1      		POP	AF
2621:10115+4	EC08  FB      		ei
2622:10119+14	EC09  ED4D    		reti
2623:				;
2624:				; mdmchk: modem input interrupt
2625:				;
2626:     -	EC0B          	mdmchk:
2627:10133+11	EC0B  F5      		push	af
2628:10144+11	EC0C  E5      		push	hl
2629:10155+10	EC0D  2121ED  		ld	hl,MdmIlen	; get # of chars in modem queue
2630:10165+7	EC10  3EAA    		ld	a,MdmIsize	; already at peak size?
2631:10172+7	EC12  BE      		cp	(hl)
2632:10179+11	EC13  DB88    		in	a,(SIODPB)	; get char
2633:10190+7+5	EC15  2825    		jr	z,mdmext	; queue full, discard
2634:10197+11	EC17  34      		inc	(hl)		; bump # of chars in modem queue
2635:10208+16	EC18  2A1FED  		ld	hl,(MdmIend)	; get tail pointer
2636:10224+7	EC1B  77      		ld	(hl),a		; store char in queue
2637:10231+6	EC1C  23      		inc	hl		; advance to next available pos'n
2638:10237+7	EC1D  3EF1    		ld	a,MdmIstop	; time to wrap around?
2639:10244+4	EC1F  BD      		cp	l
2640:10248+7+5	EC20  2003    		jr	nz,mdmchk1	; no wrap
2641:10255+10	EC22  2147F4  		ld	hl,MdmIbuf	; wrap to start of buffer
2642:     -	EC25          	mdmchk1:
2643:10265+16	EC25  221FED  		ld	(MdmIend),hl	; update tail pointer
2644:10281+13	EC28  3A21ED  		ld	a,(MdmIlen)	; check to see if it's time to turn
2645:     -	0099          	mdmctf	equ	(MdmIsize*9)/10
2646:10294+7	EC2B  FE99    		cp	mdmctf		; off RTS (buffer 90% full?)
2647:10301+7+5	EC2D  380D    		jr	c,mdmext
2648:10308+7	EC2F  3E05    		ld	a,5		; select SIO reg 5
2649:10315+11	EC31  D38C    		out	(SIOCPB),a
2650:10326+10	EC33  2159E2  		ld	hl,SIOBR5
2651:10336+7	EC36  7E      		ld	a,(hl)		; get current reg 5 setting
2652:10343+7	EC37  E6FD    		and	11111101b	; turn off RTS
2653:10350+11	EC39  D38C    		out	(SIOCPB),a	; and update SIO
2654:10361+7	EC3B  77      		ld	(hl),a		; update reg 5 setting
2655:10368+10	EC3C  E1      	mdmext:	pop	hl
2656:10378+10	EC3D  F1      		pop	af
2657:10388+4	EC3E  FB      		ei
2658:10392+14	EC3F  ED4D    		reti
2659:				;
2660:				; keysts: status change on keyboard channel
2661:				;
2662:     -	EC41          	keysts:
2663:10406+11	EC41  F5      		push	af
2664:10417+11	EC42  DB84    		in	a,(SIOCPA)	; read RR0
2665:10428+13	EC44  324FEC  		ld	(SioAstatus),a	; store DCD, CTS, RI and BREAK condition
2666:10441+7	EC47  3E10    		ld	a,10h		; reset external/status interrupts
2667:10448+11	EC49  D384    		out	(SIOCPA),a
2668:10459+10	EC4B  F1      		pop	af
2669:10469+4	EC4C  FB      		ei
2670:10473+14	EC4D  ED4D    		reti
2671:     -	EC4F  00      	SioAstatus:	db	0
2672:				;
2673:				; mdmsts: status change on modem channel
2674:				;
2675:     -	EC50          	mdmsts:
2676:10487+11	EC50  F5      		push	af
2677:10498+11	EC51  E5      		push	hl
2678:10509+11	EC52  DB8C    		in	a,(SIOCPB)	; read RR0
2679:10520+13	EC54  3276EC  		ld	(SioBstatus),a	; store DCD, CTS, RI and BREAK condition
2680:10533+4	EC57  6F      		ld	l,a
2681:10537+7	EC58  3E10    		ld	a,10h		; reset external/status interrupts
2682:10544+11	EC5A  D38C    		out	(SIOCPB),a
2683:10555+8	EC5C  CB6D    		bit	5,l		; CTS on?
2684:10563+7	EC5E  3E05    		ld	a,5		; select SIO reg 5
2685:10570+11	EC60  D38C    		out	(SIOCPB),a
2686:10581+10	EC62  2159E2  		ld	hl,SIOBR5
2687:10591+7	EC65  7E      		ld	a,(hl)		; get current reg 5 setting
2688:10598+7+5	EC66  2004    		jr	nz,CTSon
2689:     -	EC68          	CTSoff:
2690:10605+7	EC68  E6F7    		and	11110111b	; turn off Tx Enable
2691:10612+12	EC6A  1802    		jr	setCTS
2692:     -	EC6C          	CTSon:
2693:10624+7	EC6C  F608    		or	00001000b	; turn on Tx Enable
2694:     -	EC6E          	setCTS:
2695:10631+11	EC6E  D38C    		out	(SIOCPB),a	; and update SIO
2696:10642+7	EC70  77      		ld	(hl),a		; update reg 5 setting
2697:10649+10	EC71  E1      		pop	hl
2698:10659+10	EC72  F1      		pop	af
2699:10669+4	EC73  FB      		ei
2700:10673+14	EC74  ED4D    		reti
2701:     -	EC76  00      	SioBstatus:	db	0
2702:				;
2703:				; mdmTxE: channel B transmit buffer empty interrupt
2704:				;
2705:     -	EC77          	mdmTxE:
2706:10687+11	EC77  F5      		push	af
2707:10698+11	EC78  E5      		push	hl
2708:10709+10	EC79  2126ED  		ld	hl,MdmOlen
2709:10719+11	EC7C  35      		dec	(hl)		; decr # chars outstanding
2710:10730+7+5	EC7D  2814    		jr	z,mdmTxE2	; no chars outstanding now, dismiss interrupt
2711:10737+16	EC7F  2A22ED  		ld	hl,(MdmOst)	; get character to send
2712:10753+7	EC82  7E      		ld	a,(hl)
2713:10760+11	EC83  D388    		out	(SIODPB),a	; send it
2714:10771+6	EC85  23      		inc	hl		; point to next char to send
2715:10777+7	EC86  3E47    		ld	a,MdmOstop	; check for wrap at end of buffer
2716:10784+4	EC88  BD      		cp	l
2717:10788+7+5	EC89  2003    		jr	nz,mdmTxE1
2718:10795+10	EC8B  219DF3  		ld	hl,MdmObuf	; wrap to start of buffer
2719:     -	EC8E          	mdmTxE1:
2720:10805+16	EC8E  2222ED  		ld	(MdmOst),hl	; update head pointer
2721:10821+12	EC91  1804    		jr	mdmTxEx
2722:     -	EC93          	mdmTxE2:
2723:10833+7	EC93  3E28    		ld	a,28H		; reset Tx interrupt pending
2724:10840+11	EC95  D38C    		out	(SIOCPB),a
2725:     -	EC97          	mdmTxEx:
2726:10851+10	EC97  E1      		pop	hl
2727:10861+10	EC98  F1      		pop	af
2728:10871+4	EC99  FB      		ei
2729:10875+14	EC9A  ED4D    		reti
2730:				;
2731:				; CLKCHK will be called once every second from an interrupt from
2732:				; CTC channel 3. Was adapted from the clock routines developed by
2733:				; Roger Ward.
2734:				;
2735:				; Changed 05/04/89 to store date/time in format expected by
2736:				; NOVAdos/SUPRBDOS/P2DOS. DATE and TIME utilites also modified to
2737:				; reflect changes
2738:				;
2739:				; Changed 02/07/90 to be interrupt routine
2740:				;
2741:     -	EC9C          	CLKCHK:
2742:10889+11	EC9C  E5      		PUSH	HL			; save registers
2743:10900+11	EC9D  F5      		PUSH	AF
2744:10911+10	EC9E  21EEEC  		ld	hl,SECNT		; point to seconds
2745:10921+7	ECA1  7E      		LD	A,(HL)			; increment BCD seconds
2746:10928+7	ECA2  C601    		add	a,1			; NOTE: inc a doesn't work
2747:10935+4	ECA4  27      		DAA				; properly with DAA
2748:10939+7	ECA5  77      		LD	(HL),A
2749:10946+7	ECA6  FE60    		CP	60H
2750:10953+7+5	ECA8  2021    		JR	NZ,CLKEXT		; exit if no rollover
2751:10960+10	ECAA  3600    		LD	(HL),0			; seconds to ZERO
2752:				;
2753:10970+6	ECAC  2B      		DEC	HL			; point to minutes
2754:10976+7	ECAD  7E      		LD	A,(HL)			; increment BCD minutes
2755:10983+7	ECAE  C601    		add	a,1
2756:10990+4	ECB0  27      		DAA
2757:10994+7	ECB1  77      		LD	(HL),A
2758:11001+7	ECB2  FE60    		CP	60H
2759:11008+7+5	ECB4  2015    		JR	NZ,CLKEXT		; exit if no rollover
2760:11015+10	ECB6  3600    		LD	(HL),0			; minutes to ZERO
2761:				;
2762:11025+6	ECB8  2B      		DEC	HL			; point to hours
2763:11031+7	ECB9  7E      		LD	A,(HL)
2764:11038+7	ECBA  C601    		add	a,1
2765:11045+4	ECBC  27      		DAA
2766:11049+7	ECBD  77      		LD	(HL),A
2767:11056+7	ECBE  FE24    		CP	24H
2768:11063+7+5	ECC0  2009    		JR	NZ,CLKEXT		; exit, same day still
2769:11070+10	ECC2  3600    		LD	(HL),0			; hours to ZERO
2770:				;
2771:11080+16	ECC4  2AEAEC  		LD	HL,(JULCNT)
2772:11096+6	ECC7  23      		INC	HL			; increment # days since 1/1/78
2773:11102+16	ECC8  22EAEC  		LD	(JULCNT),HL
2774:				;
2775:     -	ECCB          	CLKEXT:
2776:11118+10	ECCB  F1      		POP	AF
2777:11128+10	ECCC  E1      		POP	HL
2778:     -	ECCD          	ei$reti:
2779:11138+4	ECCD  FB      		ei
2780:11142+14	ECCE  ED4D    		reti
2781:				;
2782:				; tod: get/set system time
2783:				;
2784:				;Entry parameters:
2785:				;
2786:				; If getting time
2787:				;	C = 000H to get time
2788:				; If setting time
2789:				;	C = 0FFH to set time
2790:				;	HL = pointer to NOVAdos format time table
2791:				;
2792:				;Exit parameters:
2793:				; If getting time
2794:				;	HL = pointer to NOVAdos format time table with current time
2795:				; If setting time
2796:				;	none
2797:				;
2798:     -	ECD0          	TOD:
2799:11156+11	ECD0  F5      		PUSH	AF
2800:11167+4	ECD1  79      		LD	A,C
2801:11171+4	ECD2  B7      		OR	A
2802:11175+7+5	ECD3  2810    		JR	Z,TODRD
2803:11182+11	ECD5  C5      		PUSH	BC
2804:11193+11	ECD6  D5      		PUSH	DE
2805:11204+11	ECD7  E5      		PUSH	HL
2806:11215+10	ECD8  11EAEC  		LD	DE,JULCNT		; copy time info block
2807:11225+10	ECDB  010500  		LD	BC,SECNT-JULCNT+1	; over system time
2808:11235+16+5	ECDE  EDB0    		LDIR				; block current contents
2809:11251+10	ECE0  E1      		POP	HL
2810:11261+10	ECE1  D1      		POP	DE
2811:11271+10	ECE2  C1      		POP	BC
2812:11281+10	ECE3  F1      		POP	AF
2813:11291+10	ECE4  C9      		RET	
2814:     -	ECE5          	TODRD:
2815:11301+10	ECE5  21EAEC  		LD	HL,JULCNT		; return pointer to system time
2816:11311+10	ECE8  F1      		POP	AF
2817:11321+10	ECE9  C9      		RET
2818:				;
2819:     -	ECEA  0000    	JULCNT:	DW	0			;\.
2820:     -	ECEC  00      	HRCNT:	DB	0			; NOVAdos format date/time
2821:     -	ECED  00      	MINCNT:	DB	0			; info block
2822:     -	ECEE  00      	SECNT:	DB	0			;/.
2823:				;
2824:				;	*	*	*	*	*	*	*	*
2825:				;
2826:				; LOCSTK is the common return point for operations that use
2827:				;      the local bios stack. Routine reatores the callers
2828:				;      stack pointer and returns.
2829:				;	*	*	*	*	*	*	*	*
2830:				; local stack area
2831:     -	ECEF          		DS	32		; 16 level stack
2832:     -	ED0F  13ED    	LOCSTK:	DEFW	EXIT		; exit routine
2833:     -	ED11          	OLDSTK:	DS	2		; save area for old stack
2834:11331+20	ED13  ED7B11ED	EXIT:	LD	SP,(OLDSTK)	; restore stack
2835:11351+10	ED17  C9      		RET
2836:				
2837:				;
2838:				; Storage for buffered keyboard and modem
2839:				;
2840:     -	ED18  5DF3    	KEYST:		DEFW	KEYBUF	; Storage for begining of buffer pointer
2841:     -	ED1A  5DF3    	KEYEND:		DEFW	KEYBUF	; Storage for end of buffer pointer
2842:     -	ED1C  00      	keylen:		defb	0
2843:				
2844:     -	ED1D  47F4    	MdmIst:		defw	MdmIbuf	; pointer to head of modem input buffer
2845:     -	ED1F  47F4    	MdmIend:	defw	MdmIbuf	; pointer to tail of modem input buffer
2846:     -	ED21  00      	MdmIlen:	defb	0	; # keys in modem input buffer
2847:				
2848:     -	ED22  9DF3    	MdmOst:		defw	MdmObuf	; pointer to head of modem output buffer
2849:     -	ED24  9DF3    	MdmOend:	defw	MdmObuf	; pointer to tail of modem output buffer
2850:     -	ED26  00      	MdmOlen:	defb	0	; # keys in modem output buffer
2851:     -	ED27          	MAINEND EQU	$		; End of main body of code
2852:				
2853:				;	*	*	*	*	*	*	*	*
2854:				;
2855:				;	HARD DISK Disk parameter blocks
2856:				;
2857:				;	A system configuration entry, or a user defined assembly
2858:				;	is to be used to set up the track offset entry to create
2859:				;	various hard disk partitions. This is done to support drives
2860:				;	with greater than 20Mbyte storage.
2861:				;
2862:				;	*	*	*	*	*	*	*	*
2863:     -	ED27          	HD$DPB$BASE EQU	$
2864:				;
2865:				;		# of  --mask--  disk  # of   rsv'd  chk  trk
2866:				;		sect  bs bm em  size  d ent  block  siz  ofs  x
2867:				
2868:     -	ED27  4000051F	FPARM:	DEFB	64,0,  5,31, 1, 16,0, 255,3, 255,0, 0,0, 2,0, 0
	              011000FF
	              03FF0000
	              00020000
2869:     -	ED37  4000051F	GPARM:	DEFB	64,0,  5,31, 1, 16,0, 255,3, 255,0, 0,0, 2,0, 0
	              011000FF
	              03FF0000
	              00020000
2870:				;HPARM:	DEFB	64,0,  5,31, 1, 16,0, 255,3, 255,0, 0,0, 2,0, 0
2871:				;IPARM:	DEFB	64,0,  5,31, 1, 16,0, 255,3, 255,0, 0,0, 2,0, 0
2872:				;JPARM:	DEFB	64,0,  5,31, 1, 16,0, 255,3, 255,0, 0,0, 2,0, 0
2873:				;KPARM:	DEFB	64,0,  5,31, 1, 16,0, 255,3, 255,0, 0,0, 2,0, 0
2874:				;LPARM:	DEFB	64,0,  5,31, 1, 16,0, 255,3, 255,0, 0,0, 2,0, 0
2875:				;MPARM:	DEFB	64,0,  5,31, 1, 16,0, 255,3, 255,0, 0,0, 2,0, 0
2876:				;NPARM:	DEFB	64,0,  5,31, 1, 16,0, 255,3, 255,0, 0,0, 2,0, 0
2877:				;OPARM:	DEFB	64,0,  5,31, 1, 16,0, 255,3, 255,0, 0,0, 2,0, 0
2878:				;PPARM:	DEFB	64,0,  5,31, 1, 16,0, 255,3, 255,0, 0,0, 2,0, 0
2879:				
2880:     -	0020          	HD$DPB$LEN 	EQU	$-HD$DPB$BASE
2881:     -	ED47  00      	MY$ID:		DEFB	0		; Board SCSI ID saved here
2882:     -	ED48  00      	HD$BYTE$BLOCK:	DEFB	0		; SCSI Byte/block mode saved here
2883:				
2884:				;	*	*	*	*	*	*	*	*
2885:				;
2886:				;  DIRECT SCSI DRIVER  
2887:				;
2888:				;  Entry here via the BIOS Jump tables as JMP SCSI
2889:				;
2890:				;  Enter with the following registers set:
2891:				;
2892:				;	A   SCSI target address to be used
2893:				;	HL  Pointer to SCSI Command block
2894:				;	DE  Pointer to SCSI Data Block
2895:				;
2896:				;  Exits with HL preserved.  DE is preserved if the operation is 
2897:				;  successful, otherwise DE contains the sense data (error bytes).
2898:				;  The A regisner contains the ending status of the SCSI command.
2899:				;
2900:				;  NOTE: This routine saves and restores the previous TARGET
2901:				;	address for normal operations.
2902:				;
2903:				;	*	*	*	*	*	*	*	*
2904:     -	ED49          	SCSI:
2905:11361+7	ED49  0E01    		LD	C,1		; Set C register for 1 byte block
2906:     -	ED4B          	S$HSPEED:
2907:11368+13	ED4B  323FF3  		LD	(TARGET),A	; Save target address
2908:11381+11	ED4E  E5      		PUSH	HL		; Save entry command pointer
2909:11392+11	ED4F  D5      		PUSH	DE		; .  and entry data pointer
2910:11403+16	ED50  222CF3  		LD	(CMDPTR),HL	; Set CMDPTR to what HL is pointing to
2911:11419+4	ED53  EB      		EX	DE,HL		; Set the data pointer to HL
2912:				
2913:11423+17	ED54  CD9FED  		CALL	S$CMD		; Do the direct routines
2914:				
2915:11440+7+5	ED57  2803    		JR	Z,S$END$OK	; If ok, restore cmd & data ptrs
2916:11447+10	ED59  E1      		POP	HL		; Otherwise, throw away data ptr
2917:11457+12	ED5A  1801    		JR	S$END$ERR	; .  by popping cmd pointer twice
2918:				
2919:     -	ED5C          	S$END$OK:
2920:11469+10	ED5C  D1      		POP	DE		; Restore data pointer
2921:     -	ED5D          	S$END$ERR:
2922:11479+10	ED5D  E1      		POP	HL		; Restore command pointer
2923:11489+10	ED5E  C9      		RET			; All done
2924:				
2925:				;
2926:				;  SCSI return sense data command (Cmd 03)
2927:				;
2928:     -	ED5F          	S$STAT$CMD:
2929:     -	ED5F  03      		DEFB	3		; 00 - REQUEST SENSE COMMAND
2930:     -	ED60  00      		DEFB	0		; 01 - LOGICAL UNIT
2931:     -	ED61  00      		DEFB	0		; 02 - RESERVED
2932:     -	ED62  00      		DEFB	0		; 03 - RESERVED
2933:     -	ED63  04      		DEFB	4		; 04 - NUMBER OF BYTES
2934:     -	ED64  00      		DEFB	0		; 05 - RESERVED
2935:				
2936:				;
2937:				;  SCSI read/write command (Cmd 08/0A)
2938:				;
2939:     -	0008          	S$RD$CMD EQU	08H		; 08 IS READ DATA
2940:     -	000A          	S$WR$CMD EQU	0AH		; 0A IS WRITE DATA
2941:				
2942:     -	ED65          	S$RW$CMD:
2943:     -	ED65  08      		DEFB	S$RD$CMD	; 00 - 08=Read, 0A=Write
2944:     -	ED66          	HIGH$ADDR:
2945:     -	ED66  00      		DEFB	0		; 01 - High address
2946:     -	ED67          	MED$ADDR:
2947:     -	ED67  00      		DEFB	0		; 02 - Middle address
2948:     -	ED68          	LOW$ADDR:
2949:     -	ED68  00      		DEFB	0		; 03 - Low address
2950:     -	ED69  01      		DEFB	1		; 04 - Number of sectors
2951:     -	ED6A          	STEP$RATE:
2952:     -	ED6A  00      		DEFB	0		; 05 - Step rate (Xebec)
2953:				
2954:				;	*	*	*	*	*	*	*	*
2955:				;
2956:				;  Hard disk driver (Driver #3)
2957:				;
2958:				;	FF	Select Disk
2959:				;	00	Write Disk
2960:				;	01	Read Disk
2961:				;
2962:				;	*	*	*	*	*	*	*	*
2963:11499+4	ED6B  3C      	DRVR3:	INC	A		; select command = 0ffh
2964:11503+10	ED6C  CA16E6  		JP	Z,SELEND	; do select
2965:11513+10	ED6F  2137F3  		LD	HL,TAGPHY	; Get address & step rate
2966:11523+7	ED72  7E      		LD	A,(HL)		; .
2967:11530+7	ED73  E60F    		AND	0FH		; Mask off address
2968:11537+13	ED75  326AED  		LD	(STEP$RATE),A	; Store step rate in SCSI cmd
2969:11550+6	ED78  23      		INC	HL		; Bump ptr to unit #
2970:11556+7	ED79  7E      		LD	A,(HL)		; Get unit # & type 
2971:11563+7	ED7A  E6E0    		AND	0E0H		; Mask off type
2972:11570+13	ED7C  3240F3  		LD	(LOGUNIT),A	; Save unit #
2973:11583+6	ED7F  23      		INC	HL		; Bump ptr to SCSI addr
2974:11589+7	ED80  7E      		LD	A,(HL)		; Get SCSI address
2975:11596+13	ED81  323FF3  		LD	(TARGET),A	; Save as target address
2976:				
2977:				; fall through to S$IO and do the read/write
2978:				
2979:				;	*	*	*	*	*	*	*	*
2980:				;
2981:				;  SCSI READ/WRITE HOST ROUTINES
2982:				;
2983:				;  Entry here from the HOSTIO section of the blocking/deblock
2984:				;  routines. Assumes that the TARGET address has been pre-set.
2985:				;
2986:				;  Exits with the error code in (A), and the sense status saved
2987:				;  at S$STAT$DAT if an error occurs.
2988:				;
2989:				;	*	*	*	*	*	*	*	*
2990:     -	ED84          	S$IO:
2991:11609+13	ED84  3A50F3  		LD	A,(RWHOST)
2992:11622+4	ED87  A7      		AND	A		; write = 0
2993:				;
2994:				;  Write to the hard disk described by (TARGET) and (LOGUNIT)
2995:				;
2996:     -	ED88          	S$WR:
2997:11626+7	ED88  3E0A    		LD	A,S$WR$CMD	; Set write command 
2998:11633+7+5	ED8A  2802    		JR	Z,S$DO$RW
2999:				
3000:				;
3001:				;  Read from the hard disk described by (TARGET) and (LOGUNIT)
3002:				;
3003:     -	ED8C          	S$RD:
3004:11640+7	ED8C  3E08    		LD	A,S$RD$CMD	; Set read command
3005:				
3006:				;
3007:				;  Do the rest of the setup for the read/write command
3008:				;
3009:     -	ED8E          	S$DO$RW:
3010:					
3011:11647+10	ED8E  2165ED  		LD	HL,S$RW$CMD	; Get command string
3012:11657+7	ED91  77      		LD	(HL),A		; Plug the SCSI command 
3013:11664+16	ED92  222CF3  		LD	(CMDPTR),HL	; Save the command pointer
3014:11680+17	ED95  CDF6ED  		CALL	BLD$S$SCTR	; Build SCSI sector address
3015:11697+10	ED98  212AEF  		LD	HL,HSTBUF	; Get pointer to host buffer
3016:11707+13	ED9B  3A48ED  		LD	A,(HD$BYTE$BLOCK) ; Get SCSI byte/block mode value
3017:11720+4	ED9E  4F      		LD	C,A		; Stuff in C register
3018:				
3019:				;
3020:				;  Enter here from the SCSI direct driver routine
3021:				;
3022:				;  Exits with status in A.  0FFH = timeout error
3023:				;
3024:     -	ED9F          	S$CMD:
3025:11724+16	ED9F  222EF3  		LD	(DATPTR),HL	; Save the data pointer
3026:11740+10	EDA2  2123EF  		LD	HL,INT$RETRIES	; retry save area
3027:11750+10	EDA5  3602    		LD	(HL),2		; retries
3028:11760+10	EDA7  213AF3  		LD	HL,S$IO$COUNT ; And the # of bytes to transfer
3029:11770+7	EDAA  71      		LD	(HL),C		; .  at one time (each block)
3030:				
3031:     -	EDAB          	S$CMD$RETRY:
3032:11777+17	EDAB  CD16EE  		CALL	SELECT		; Perform the SCSI operation
3033:11794+13	EDAE  3A2AF3  		LD	A,(STATUS)	; Get the return status
3034:11807+13	EDB1  3224EF  		LD	(ERFLAG),A	; Save ending status
3035:11820+7	EDB4  FEFF    		CP	0FFH		; Timeout?
3036:11827+7+5	EDB6  283C    		JR	Z,S$DONE	; Yes, go save timeout status
3037:11834+7	EDB8  E602    		AND	2		; Check for SCSI error status
3038:11841+5+6	EDBA  C8      		RET	Z		; No error -- return
3039:				
3040:11846+10	EDBB  2123EF  		LD	HL,INT$RETRIES	; see if any retries remain
3041:11856+11	EDBE  35      		DEC	(HL)
3042:11867+7+5	EDBF  2833    		JR	Z,S$DONE	; NO more remain, exit and set flags
3043:				
3044:				; Save current command and data pointers.
3045:				
3046:11874+16	EDC1  2A2EF3  		LD	HL,(DATPTR)	; save old data pointer
3047:11890+16	EDC4  225AF3  		LD	(SAVE$DATPTR),HL
3048:11906+16	EDC7  2A2CF3  		LD	HL,(CMDPTR)	; save old command pointer
3049:11922+16	EDCA  2258F3  		LD	(SAVE$CMDPTR),HL
3050:11938+7	EDCD  3E01    		LD	A,1
3051:11945+13	EDCF  323AF3  		LD	(S$IO$COUNT),A ; force byte xfer mode for retries..
3052:				
3053:				; Request SCSI sense.
3054:				
3055:11958+10	EDD2  213BF3  		LD	HL,S$STAT$DAT ; .  for request sense command
3056:11968+16	EDD5  222EF3  		LD	(DATPTR),HL
3057:11984+10	EDD8  215FED  		LD	HL,S$STAT$CMD ; Set up data and command pointers
3058:11994+16	EDDB  222CF3  		LD	(CMDPTR),HL
3059:12010+13	EDDE  3A40F3  		LD	A,(LOGUNIT)	; Get logical unit number
3060:12023+6	EDE1  23      		INC	HL		; Stuff in proper location in
3061:12029+7	EDE2  77      		LD	(HL),A		; .  SCSI command
3062:12036+17	EDE3  CD16EE  		CALL	SELECT		; Execute request sense command
3063:				
3064:				; Restore pointers and retry command
3065:				
3066:12053+16	EDE6  2A5AF3  		LD	HL,(SAVE$DATPTR) ; restore old data pointer
3067:12069+16	EDE9  222EF3  		LD	(DATPTR),HL
3068:12085+16	EDEC  2A58F3  		LD	HL,(SAVE$CMDPTR) ; restore old command pointer
3069:12101+16	EDEF  222CF3  		LD	(CMDPTR),HL
3070:12117+12	EDF2  18B7    		JR	S$CMD$RETRY	; command retry
3071:				
3072:     -	EDF4          	S$DONE:
3073:12129+4	EDF4  B7      		OR	A		; Set Z/NZ for user
3074:12133+10	EDF5  C9      		RET			; and return
3075:				
3076:				;	*	*	*	*	*	*	*	*
3077:				;
3078:				;  Build 3-byte SCSI sector number and logical unit number
3079:				;
3080:				;  NOTE:  This routine assumes 16 sectors per track.
3081:				;
3082:				;  It is safe to assume 16 sectors per track even though some hard
3083:				;  disk controllers format more (Xebec=17, Adaptec=18, etc.) as the
3084:				;  read and write commands use a block number, rather than a track
3085:				;  and sector number to move to the correct block to read or write.
3086:				;
3087:				;	*	*	*	*	*	*	*	*
3088:     -	EDF6          	BLD$S$SCTR:
3089:12143+4	EDF6  AF      		XOR	A		; Clear A & Carry
3090:				
3091:								; A reg     C  HL reg pair
3092:12147+16	EDF7  2A15EF  		LD	HL,(CPMTRK)	; --------  -  FEDCBA9876543210
3093:12163+11	EDFA  29      		ADD	HL,HL		; --------  F  EDCBA9876543210-
3094:12174+4	EDFB  17      		RLA			; -------F  -  EDCBA9876543210-
3095:12178+11	EDFC  29      		ADD	HL,HL		; -------F  E  DCBA9876543210--
3096:12189+4	EDFD  17      		RLA			; ------FE  -  DCBA9876543210--
3097:12193+11	EDFE  29      		ADD	HL,HL		; ------FE  D  CBA9876543210---
3098:12204+4	EDFF  17      		RLA			; -----FED  -  CBA9876543210---
3099:12208+11	EE00  29      		ADD	HL,HL		; -----FED  C  BA9876543210----
3100:12219+4	EE01  17      		RLA			; ----FEDC  -  BA9876543210----
3101:12223+4	EE02  47      		LD	B,A		; 
3102:12227+13	EE03  3A40F3  		LD	A,(LOGUNIT)	; 
3103:12240+4	EE06  B0      		OR	B		; Or in logical unit number
3104:12244+13	EE07  3266ED  		LD	(HIGH$ADDR),A	; Save unit number & high byte
3105:12257+4	EE0A  7C      		LD	A,H		; 
3106:12261+13	EE0B  3267ED  		LD	(MED$ADDR),A	; Save middle byte
3107:12274+13	EE0E  3A13EF  		LD	A,(HSTSEC)	; Get sector number
3108:12287+4	EE11  B5      		OR	L		; Or in low byte
3109:12291+13	EE12  3268ED  		LD	(LOW$ADDR),A	; Save new low byte
3110:12304+10	EE15  C9      		RET
3111:				
3112:				;
3113:				;  Select controller, and fall through to phase if selected ok.
3114:				;
3115:     -	0040          	BUSBSY	EQU	40H
3116:				
3117:12314+4	EE16  AF      	SELECT:	XOR	A
3118:12318+11	EE17  D321    		OUT	(NCRICR),A	; Clear initiator command register
3119:12329+11	EE19  D323    		OUT	(NCRTCR),A	; .  and target command register
3120:				
3121:     -	EE1B          	CLEAR$ARBIT:
3122:12340+4	EE1B  AF      		XOR	A
3123:12344+11	EE1C  D322    		OUT	(NCRMR),A	; .
3124:12355+11	EE1E  DB27    		IN	A,(NCRRPI)	; reset interrupts
3125:				
3126:12366+13	EE20  3A47ED  		LD	A,(MY$ID)	; Select target: get our ID,
3127:12379+4	EE23  47      		LD	B,A		; .
3128:12383+13	EE24  3A3FF3  		LD	A,(TARGET)	; .  or in target ID
3129:12396+4	EE27  B0      		OR	B		; .
3130:12400+11	EE28  D320    		OUT	(NCRODR),A	; .  and send to NCR chip
3131:				
3132:12411+11	EE2A  DB21    		IN	A,(NCRICR)
3133:12422+7	EE2C  F601    		OR	01H		; Assert data bus
3134:12429+11	EE2E  D321    		OUT	(NCRICR),A	; .
3135:				
3136:12440+7	EE30  3E05    		LD	A,05H		; Release BSY, keep SEL	
3137:12447+11	EE32  D321    		OUT	(NCRICR),A	; .  and assert data bus
3138:				
3139:12458+10	EE34  010060  		LD	BC,6000H	; 250 ms loop (1M cycles)
3140:     -	EE37          	STIM:
3141:12468+11	EE37  DB24    		IN	A,(NCRCSBS)	; Wait for BSY
3142:12479+7	EE39  E640    		AND	BUSBSY		; .
3143:12486+7+5	EE3B  200F    		JR	NZ,SELECT$OK	; Got him!
3144:				
3145:12493+4	EE3D  0D      		DEC	C
3146:12497+7+5	EE3E  20F7    		JR	NZ,STIM		; inner loop:  41*256 = 10496 cycles
3147:12504+4	EE40  05      		DEC	B
3148:12508+7+5	EE41  20F4    		JR	NZ,STIM		; outer loop: 10510*96 = 1M cycles
3149:				
3150:12515+4	EE43  AF      		XOR	A		; Select timeout -- clear bus
3151:12519+11	EE44  D320    		OUT	(NCRODR),A
3152:				
3153:12530+4	EE46  3D      		DEC	A		; set timeout to 'a'
3154:12534+13	EE47  322AF3  		LD	(STATUS),A
3155:12547+12	EE4A  1801    		JR	ALL$DONE	; and clear the registers
3156:				
3157:     -	EE4C          	SELECT$OK:
3158:12559+4	EE4C  AF      		XOR	A		; Set good status
3159:				
3160:     -	EE4D          	ALL$DONE:
3161:12563+4	EE4D  47      		LD	B,A		; save status
3162:12567+7	EE4E  3E01    		LD	A,01H		; Release SEL
3163:12574+11	EE50  D321    		OUT	(NCRICR),A	; .
3164:12585+4	EE52  AF      		XOR	A		; Release data bus
3165:12589+11	EE53  D321    		OUT	(NCRICR),A	; .
3166:12600+4	EE55  78      		LD	A,B		; get status back
3167:12604+4	EE56  B7      		OR	A		; Set status
3168:12608+5+6	EE57  C0      		RET	NZ
3169:12613+4	EE58  3D      		DEC	A		; clear scsi status to timeout, 0ffh
3170:12617+13	EE59  322AF3  		LD	(STATUS),A	; Save status for PWIDIR routine
3171:				
3172:				; SCSI.011
3173:				; * * * * *  
3174:				; *  --------\	NOTE: we fall through if we successfully
3175:				; *  --------/	selected the controller!!
3176:				; * * * * *
3177:				
3178:12630+7	EE5C  3E06    		LD	A,00000110B	; Set DMA mode and Monitor Busy  
3179:12637+11	EE5E  D322    		OUT	(NCRMR),A	; .
3180:				
3181:     -	EE60          	S$RDY:
3182:				; Wait for either a 5380 "Interrupt" or a REQ from Target.
3183:				; The REQ is needed since it may have come too soon after
3184:				; selection to register an Interrupt.
3185:12648+11	EE60  DB25    		IN	A,(NCRBSR)	; Check for "Interrupt"
3186:12659+7	EE62  E610    		AND	00010000B	; .
3187:12666+7+5	EE64  2008    		JR	NZ,S$INT
3188:12673+11	EE66  DB24    		IN	A,(NCRCSBS)	; Check for REQ
3189:12684+7	EE68  E620    		AND	NCRREQ		; .
3190:								; Wait for Interrupt or REQ
3191:12691+7+5	EE6A  28F4    		JR	Z,S$RDY
3192:12698+12	EE6C  1809    		JR	S$PHASE		; Process phase vector
3193:				
3194:     -	EE6E          	S$INT:
3195:				;  Determine cause of 5380 "Interrupt".  Either phase
3196:				;  changed, busy dropped, or bus was reset.  If bits 2 and 3
3197:				;  of the NCRBSR are not 0's when the Interrupt flag (bit 4)
3198:				;  is set, then it is either a loss of BUSY or an SCSI RESET.
3199:12710+4	EE6E  AF      		XOR	A
3200:12714+11	EE6F  D321    		OUT	(NCRICR),A	; Release data bus
3201:12725+11	EE71  DB25    		IN	A,(NCRBSR)	; Read 5380 Bus and Stat Reg
3202:12736+7	EE73  E60C    		AND	00001100B	; Keep interesting bits
3203:12743+7+5	EE75  2056    		JR	NZ,S$EXIT
3204:								; Reset or Busy Loss: Exit
3205:								; 00 --> Process phase vector
3206:				
3207:     -	EE77          	S$PHASE:
3208:				; DMA mode and Monitor Busy must be cleared prior to clearing
3209:				; of the 5380 Interrupt Flag.  Then mode register is restored.
3210:				; Otherwise the interrupt flag may not clear and the DMA Mode 
3211:				; may not be useable.  
3212:12750+4	EE77  AF      		XOR	A		; Clear 5380 Mode Register
3213:12754+11	EE78  D322    		OUT	(NCRMR),A	; .
3214:12765+11	EE7A  DB27    		IN	A,(NCRRPI)	; Reset interrupts
3215:12776+7	EE7C  3E06    		LD	A,00000110B	; Set DMA mode and Monitor Busy
3216:12783+11	EE7E  D322    		OUT	(NCRMR),A	; .
3217:12794+11	EE80  DB24    		IN	A,(NCRCSBS)	; Update phase...
3218:12805+7	EE82  E61C    		AND	00011100B	; Mask all but phase bits, clear carry bit
3219:12812+4	EE84  1F      		RRA			; Rotate over for target
3220:12816+4	EE85  5F      		LD	E,A		; . (Save for use with jump table)
3221:12820+4	EE86  1F      		RRA			; .
3222:12824+11	EE87  D323    		OUT	(NCRTCR),A	; Set phase
3223:12835+7	EE89  1600    		LD	D,0		; E is already set (3 ins ago)
3224:12842+10	EE8B  2196EE  		LD	HL,PHASE$TABLE	; Get phase jump table base
3225:12852+11	EE8E  19      		ADD	HL,DE		; Add offset for this phase
3226:12863+7	EE8F  7E      		LD	A,(HL)		; Get phase pointer into HL
3227:12870+6	EE90  23      		INC	HL		; .
3228:12876+7	EE91  66      		LD	H,(HL)		; .
3229:12883+4	EE92  6F      		LD	L,A		; Pointer is now together
3230:12887+7	EE93  1640    		LD	D,01000000B	; DMA request mask(used by RSCSI and WSCSI)
3231:12894+4	EE95  E9      		JP	(HL)		; Go to it!
3232:				
3233:     -	EE96          	PHASE$TABLE:
3234:     -	EE96  A6EE    		DEFW	PHASE0
3235:     -	EE98  AFEE    		DEFW	PHASE1
3236:     -	EE9A  B8EE    		DEFW	PHASE2
3237:     -	EE9C  BFEE    		DEFW	PHASE3
3238:     -	EE9E  CDEE    		DEFW	PHASE4
3239:     -	EEA0  CDEE    		DEFW	PHASE5
3240:     -	EEA2  CDEE    		DEFW	PHASE6
3241:     -	EEA4  C6EE    		DEFW	PHASE7
3242:				
3243:     -	EEA6          	PHASE0:				; Data out phase ...
3244:12898+10	EEA6  213AF3  		LD	HL,S$IO$COUNT ; Point to byte/block transfer mode
3245:12908+7	EEA9  5E      		LD	E,(HL)		; Get transfer mode value
3246:12915+16	EEAA  2A2EF3  		LD	HL,(DATPTR)	; Use data pointer
3247:12931+12	EEAD  1826    		JR	WSCSI		; Execute SCSI write routine
3248:				
3249:     -	EEAF          	PHASE1:				; Data in phase ...
3250:12943+10	EEAF  213AF3  		LD	HL,S$IO$COUNT ; Point to byte/block transfer mode
3251:12953+7	EEB2  5E      		LD	E,(HL)		; Get transfer mode value
3252:12960+16	EEB3  2A2EF3  		LD	HL,(DATPTR)	; Use data pointer
3253:12976+12	EEB6  183A    		JR	RSCSI		; Execute SCSI read routine
3254:				
3255:     -	EEB8          	PHASE2:				; Command out phase ...
3256:12988+16	EEB8  2A2CF3  		LD	HL,(CMDPTR)	; Use command pointer
3257:13004+7	EEBB  1E01    		LD	E,1		; Set mode to byte transfer
3258:13011+12	EEBD  1816    		JR	WSCSI		; Execute SCSI write routine
3259:				
3260:     -	EEBF          	PHASE3:				; Status in phase ...
3261:13023+10	EEBF  212AF3  		LD	HL,STATUS	; Use status pointer
3262:13033+7	EEC2  1E01    		LD	E,1		; Set mode to byte transfer
3263:13040+12	EEC4  182C    		JR	RSCSI		; Execute SCSI read routine
3264:				
3265:     -	EEC6          	PHASE7:				; Message in phase ...
3266:13052+10	EEC6  212BF3  		LD	HL,MESSAGE	; Use message pointer
3267:13062+7	EEC9  1E01    		LD	E,1		; Set mode to byte transfer
3268:13069+12	EECB  1825    		JR	RSCSI		; Execute SCSI read routine
3269:				
3270:				; Currently unused phases
3271:				
3272:     -	EECD          	PHASE4:
3273:     -	EECD          	PHASE5:
3274:     -	EECD          	PHASE6:
3275:     -	EECD          	S$EXIT:
3276:13081+4	EECD  AF      		XOR	A		; Clean up 5380 and exit.
3277:13085+11	EECE  D323    		OUT	(NCRTCR),A	; .
3278:13096+11	EED0  D322    		OUT	(NCRMR),A	; .
3279:13107+11	EED2  DB27    		IN	A,(NCRRPI)	; Reset interrupts
3280:13118+10	EED4  C9      		RET			; .
3281:				
3282:				; Generalized SCSI write routine
3283:				
3284:     -	EED5          	WSCSI:
3285:13128+4	EED5  F3      		di
3286:13132+7	EED6  3E01    		LD	A,1		; Assert data bus
3287:13139+11	EED8  D321    		OUT	(NCRICR),A
3288:13150+7	EEDA  0E28    		LD	C,NCRDACK	; Set up destination port address
3289:13157+11	EEDC  D325    		OUT	(NCRSDS),A	; Start DMA send
3290:				
3291:				; Wait for DMA request, keeping an eye on phase.  Note that the NCR
3292:				; will not issue an ACK, nor will it generate DMA requests once the
3293:				; phase changes, so it is best to treat DMA request checking as a
3294:				; higher priority than phase change checking.
3295:				
3296:     -	EEDE          	WSCSI1:
3297:13168+11	EEDE  DB25    		IN	A,(NCRBSR)
3298:13179+4	EEE0  47      		LD	B,A		; Save status for use below
3299:13183+4	EEE1  A2      		AND	D		; Check for DMA request
3300:13187+7+5	EEE2  2805    		JR	Z,WSCSI2
3301:				
3302:				; This is the heart of the pseudo-DMA transfer.  On entry, HL points
3303:				; to the data buffer and E should be 0 for 256 byte block transfer,
3304:				; or 1 for byte-by-byte transfer.  NOTE: Use block transfer only if
3305:				; you can be sure the controller can buffer 256 bytes of data and
3306:				; can transfer at 5.25 us per byte.  Extra DACK's after the last REQ
3307:				; will do no harm.
3308:				;
3309:				; OTIR register use: H = memory pointer, C = I/O port, B = counter
3310:				; 
3311:13194+4	EEE4  43      		LD	B,E		; Set up loop count
3312:13198+16+5	EEE5  EDB3    		OTIR
3313:13214+12	EEE7  18F5    		JR	WSCSI1		; Write more bytes until phase changes
3314:				
3315:				; This code skipped when data is being transferred ...
3316:     -	EEE9          	WSCSI2:
3317:13226+4	EEE9  78      		LD	A,B		; Check 5380 "interrupt" flag
3318:13230+7	EEEA  E610    		AND	00010000B	; .
3319:13237+7+5	EEEC  28F0    		JR	Z,WSCSI1	; Wait for DMA request,
3320:13244+4	EEEE  FB      		ei
3321:13248+10	EEEF  C36EEE  		JP	S$INT	;  or process "interrupt"
3322:				
3323:				; Generalized SCSI read routine
3324:				
3325:     -	EEF2          	RSCSI:
3326:				; Initiator command reg is already initialized
3327:				
3328:13258+4	EEF2  F3      		di
3329:13262+7	EEF3  0E28    		LD	C,NCRDACK	; Source port address
3330:13269+11	EEF5  D327    		OUT	(NCRSDIR),A	; Write to this port starts dma recieve
3331:				
3332:				; Wait for DMA request, keeping an eye on phase.  Note: we must do
3333:				; a check for DMA request before checking for a phase change, since
3334:				; a byte may be queued up waiting to be DACKed prior to the phase
3335:				; change.
3336:				;
3337:     -	EEF7          	RSCSI1:
3338:13280+11	EEF7  DB25    		IN	A,(NCRBSR)
3339:13291+4	EEF9  47      		LD	B,A		; Keep for phase change checking
3340:13295+4	EEFA  A2      		AND	D		; Mask for DMA request
3341:13299+7+5	EEFB  2805    		JR	Z,RSCSI2
3342:				
3343:				; This is the heart of the pseudo-DMA transfer.  On entry, HL points
3344:				; to the data buffer and E should be 0 for 256 byte block transfer,
3345:				; or 1 for byte-by-byte transfer.  NOTE: Use block transfer only if
3346:				; you can be sure the controller can buffer 256 bytes of data and
3347:				; can transfer at 5.25 us per byte.  Extra DACK's after the last REQ
3348:				; will do no harm.
3349:				;
3350:				; INIR register use: H = memory pointer, C = I/O port, B = counter
3351:				; 
3352:13306+4	EEFD  43      		LD	B,E		; Set up loop count
3353:13310+16+5	EEFE  EDB2    		INIR
3354:13326+12	EF00  18F5    		JR	RSCSI1		; Read more bytes until phase changes
3355:								; Be sure and check phase if no DMA
3356:								; request, since NCR won't issue any
3357:								; unneeded DACKs
3358:				
3359:				; This code skipped when data is being transferred ...
3360:     -	EF02          	RSCSI2:
3361:13338+4	EF02  78      		LD	A,B		; Check 5380 "interrupt" flag
3362:13342+7	EF03  E610    		AND	00010000B	; .
3363:13349+7+5	EF05  28F0    		JR	Z,RSCSI1	; Wait for DMA request,
3364:13356+4	EF07  FB      		ei
3365:13360+10	EF08  C36EEE  		JP	S$INT		;  or process "interrupt"
3366:				
3367:     -	EF0B          	HDCODE	EQU	$		; End of hard disk code
3368:				
3369:				;	*	*	*	*	*	*	*	*
3370:				;
3371:				;	COLD BOOT ENTRY
3372:				;
3373:				;	NOTE: The following code does not stay resident. It is 
3374:				;	overlayed for use by all bios system variables.
3375:				;
3376:				;	*	*	*	*	*	*	*	*
3377:     -	EF0B          	BOOT:
3378:13370+4	EF0B  F3      		DI
3379:13374+7	EF0C  3E41    		LD	A,41H		; Turn off EPROM, but leave drive 0
3380:13381+11	EF0E  D300    		OUT	(CONT),A	; . selected (1770 turns it off)
3381:13392+7	EF10  3EE3    		LD	A,VECTORS/256	; set up interrupt vector
3382:13399+9	EF12  ED47    		LD	I,A		; page address
3383:13408+8	EF14  ED5E    		IM	2
3384:13416+13	EF16  3A61E2  		LD	A,(IOBYT)	; Initialize IOBYTE
3385:13429+13	EF19  320300  		LD	(IOBYTE),A
3386:13442+10	EF1C  318000  		LD	SP,80H		; Initialize DART, CTC, etc.
3387:13452+17	EF1F  CDACE3  		CALL	IOINIT		; .
3388:13469+11	EF22  DB84    		IN	A,(SIOCPA)
3389:13480+13	EF24  324FEC  		LD	(SioAstatus),A
3390:13493+11	EF27  DB8C    		IN	A,(SIOCPB)
3391:13504+13	EF29  3276EC  		LD	(SioBstatus),A
3392:13517+7	EF2C  3E10    		LD	A,10H		; reset ext/status interrupts
3393:13524+11	EF2E  D384    		OUT	(SIOCPA),A	; on both channels
3394:13535+11	EF30  D38C    		OUT	(SIOCPB),A
3395:				;
3396:13546+11	EF32  DB29    		IN	A,(029H)	; Get ID value
3397:13557+7	EF34  E607    		AND	07H		; Mask off extra bits
3398:13564+4	EF36  47      		LD	B,A		; Bump to make 1 - 8
3399:13568+4	EF37  04      		INC	B		; Convert to SCSI address
3400:13572+7	EF38  C630    		ADD	A,'0'		; . (Put ID in inital message)
3401:13579+13	EF3A  3241F0  		LD	(S$ID$FOUND),A ; . .
3402:13592+4	EF3D  AF      		XOR	A		; .  (Clear receiving register)
3403:13596+4	EF3E  37      		SCF			; .  (Carry = bit to rotate)
3404:     -	EF3F          	NEXT$BIT:
3405:13600+4	EF3F  17      		RLA			; .  (Rotate left through carry)
3406:13604+8+5	EF40  10FD    		DJNZ	NEXT$BIT	; .  (Not done -- repeat)
3407:13612+13	EF42  3247ED  		LD	(MY$ID),A	; Save ID value
3408:				
3409:     -	EF45          	NOT7:
3410:13625+4	EF45  AF      		XOR	A		; Clear 5380 registers (SCSI init)
3411:13629+11	EF46  D321    		OUT	(NCRICR),A	; .
3412:13640+11	EF48  D322    		OUT	(NCRMR),A	; .
3413:13651+11	EF4A  D323    		OUT	(NCRTCR),A	; .
3414:13662+11	EF4C  D324    		OUT	(NCRSER),A	; .
3415:								; End of HD initialization
3416:				
3417:13673+10	EF4E  21ADEF  		LD	HL,LOGMSG	; Display signon message
3418:13683+17	EF51  CD1BE5  		CALL	PUTS
3419:				
3420:13700+10	EF54  21C1F1  		LD	HL,DRIVE$TDATA	; Init drive type data
3421:13710+10	EF57  1170E2  		LD	DE,DRIVE$TYPES
3422:13720+10	EF5A  010800  		LD	BC,8
3423:13730+16+5	EF5D  EDB0    		LDIR
3424:				
3425:				; Init ZCPR3 stuff if present
3426:				
3427:13746+10	EF5F  21C9F1  		LD	HL,LAST$SG	; Set up HL and DE to clear memory
3428:13756+10	EF62  11CAF1  		LD	DE,LAST$SG+1	; from the end of boot to 0ffffh
3429:13766+10	EF65  01360E  		LD	BC,0FFFFH-LAST$SG
3430:13776+10	EF68  3600    		LD	(HL),0
3431:13786+16+5	EF6A  EDB0    		LDIR
3432:				
3433:13802+10	EF6C  010300  	ZBOOT:	LD	BC,CMDSET$END-CMDSET
3434:13812+10	EF6F  21B9F1  		LD	HL,CMDSET	; Set up the ZCPR3 command line
3435:13822+10	EF72  1100FF  		LD	DE,Z3CL		; .  pointers
3436:13832+16+5	EF75  EDB0    		LDIR			; 
3437:				
3438:13848+10	EF77  010A00  		LD	BC,AUTCMD$END-AUTOCMD
3439:13858+10	EF7A  2162E2  		LD	HL,AUTOCMD	; Move the automatic command to
3440:13868+10	EF7D  1103FF  		LD	DE,Z3CL+3	; .  the ZCPR3 command line 
3441:13878+16+5	EF80  EDB0    		LDIR			; 
3442:				
3443:13894+10	EF82  010500  		LD	BC,PATH$END-PATH; Move the initial path descriptor
3444:13904+10	EF85  21BCF1  		LD	HL,PATH		; .  to the proper location
3445:13914+10	EF88  114000  		LD	DE,EXPATH	; 
3446:13924+16+5	EF8B  EDB0    		LDIR			; 
3447:				
3448:13940+10	EF8D  214B00  		LD	HL,Z3WHL	; Turn the wheel byte on
3449:13950+10	EF90  36FF    		LD	(HL),0FFH	; 
3450:				
3451:13960+10	EF92  21C4F0  		LD	HL,ENV		; Move environment and TCAP to the
3452:13970+10	EF95  1100FE  		LD	DE,Z3ENV	; .  proper location
3453:13980+10	EF98  01F600  		LD	BC,ENVEND-ENV+1	; .
3454:13990+16+5	EF9B  EDB0    		LDIR			; 
3455:				
3456:14006+4	EF9D  AF      		XOR	A		; 
3457:14010+13	EF9E  320400  		LD	(CDISK),A	; Indicate disk 0 selected
3458:14023+13	EFA1  3219EF  		LD	(HSTACT),A	; Set host buffer inactive
3459:14036+13	EFA4  321BEF  		LD	(UNACNT),A	; Clear unalloc count
3460:14049+13	EFA7  3251F3  		LD	(HSTSID),A	; Assume side zero
3461:14062+10	EFAA  C36DE5  		JP	GOCPM		; Initialize & jump to CP/M
3462:				
3463:     -	EFAD  0D0A0A07	LOGMSG:	DEFB	CR,LF,LF,BELL,ESC,'[#1w',CR
	              1B5B2331
	              770D
3464:     -	EFB7  3538    		DEFB	MSIZE/10+'0',MSIZE % 10 +'0'
3465:     -	EFB9  4B205A43		DEFB	'K ZCPR',Z3REV/10+'0','.',Z3REV % 10+'0'
	              5052332E
	              33
3466:     -	EFC2  2F4E4F56		DEFB	'/NOVAdos Z80 Operating System'
	              41646F73
	              205A3830
	              204F7065
	              72617469
	              6E672053
	              79737465
	              6D
3467:     -	EFDF  0D0A414D		DEFB	CR,LF,'AMPRO BIOS Version ',VERS/10+'0','.'
	              50524F20
	              42494F53
	              20566572
	              73696F6E
	              20342E
3468:     -	EFF6  33      		DEFB	VERS % 10+'0'
3469:     -	EFF7  0D0A436F		DEFB	CR,LF,'Copyright (C) 1983,84,85,86 '
	              70797269
	              67687420
	              28432920
	              31393833
	              2C38342C
	              38352C38
	              3620
3470:     -	F015  414D5052		DEFB	'AMPRO Computers, Inc.'
	              4F20436F
	              6D707574
	              6572732C
	              20496E63
	              2E
3471:     -	F02A  0D0A0A53		DEFB	CR,LF,LF,'SCSI initiator ID = '
	              43534920
	              696E6974
	              6961746F
	              72204944
	              203D20
3472:     -	F041          	S$ID$FOUND:
3473:     -	F041  78      		DEFB	'x'
3474:     -	F042  0D0A2841		DEFB	CR,LF,'(Arbitration Disabled)'
	              72626974
	              72617469
	              6F6E2044
	              69736162
	              6C656429
3475:     -	F05A  0D0A284E		DEFB	CR,LF,'(NOVAdos Clock Interrupt Enabled)'
	              4F564164
	              6F732043
	              6C6F636B
	              20496E74
	              65727275
	              70742045
	              6E61626C
	              656429
3476:     -	F07D  0D0A284B		DEFB	CR,LF,'(Keyboard Input Interrupt Enabled)'
	              6579626F
	              61726420
	              496E7075
	              7420496E
	              74657272
	              75707420
	              456E6162
	              6C656429
3477:     -	F0A1  0D0A284D		DEFB	CR,LF,'(Modem I/O Interrupts Enabled)'
	              6F64656D
	              20492F4F
	              20496E74
	              65727275
	              70747320
	              456E6162
	              6C656429
3478:     -	F0C1  0D0A00  		DEFB	CR,LF,0
3479:     -	F0C4          	ENV:
3480:14072+10	F0C4  C300E2  		JP	BIOS		; FE00 Leading JMP
3481:     -	F0C7          	ENV1:				; ZCPR3 enviornment descriptor ...
3482:     -	F0C7  5A33454E		DEFB	'Z3ENV'		; FE03. Environment ID
	              56
3483:     -	F0CC  80      		DEFB	80h		; FE08 . extended environment
3484:     -	F0CD  4000    		DEFW	EXPATH		; FE09 . External path (PATH)
3485:     -	F0CF  05      		DEFB	EXPATHS		; FE0B
3486:     -	F0D0  0000    		DEFW	RCP		; FE0C . Resident command package (RCP)
3487:     -	F0D2  00      		DEFB	RCPS		; FE0E
3488:     -	F0D3  0000    		DEFW	IOP		; FE0F . Input/output package (IOP)
3489:     -	F0D5  00      		DEFB	IOPS		; FE11 
3490:     -	F0D6  00F9    		DEFW	FCP		; FE12 . Flow command package (FCP)
3491:     -	F0D8  06      		DEFB	FCPS		; FE14
3492:     -	F0D9  00FC    		DEFW	Z3NDIR		; FE15 . Named directories (NDR)
3493:     -	F0DB  0E      		DEFB	Z3NDIRS		; FE17
3494:     -	F0DC  00FF    		DEFW	Z3CL		; FE18 . Command line (CL)
3495:     -	F0DE  C8      		DEFB	Z3CLS		; FE1A
3496:     -	F0DF  00FE    		DEFW	Z3ENV		; FE1B . Environment (ENV)
3497:     -	F0E1  02      		DEFB	Z3ENVS		; FE1D
3498:     -	F0E2  00FD    		DEFW	SHSTK		; FE1E . Shell stack (SH)
3499:     -	F0E4  04      		DEFB	SHSTKS		; FE20
3500:     -	F0E5  20      		DEFB	SHSIZE		; FE21
3501:     -	F0E6  80FD    		DEFW	Z3MSG		; FE22 . Message buffer (MSG)
3502:     -	F0E8  D0FD    		DEFW	EXTFCB		; FE24 . External FCB (FCB)
3503:     -	F0EA  D0FF    		DEFW	EXTSTK		; FE26 . External stack (STK)
3504:     -	F0EC  00      		DEFB	0		; FE28 . Quiet flag (1=quiet, 0=not quiet)
3505:     -	F0ED  4B00    		DEFW	Z3WHL		; FE29 . Wheel byte (WHL)
3506:     -	F0EF  04      		DEFB	4		; FE2B . Processor speed (Mhz)
3507:     -	F0F0  05      		DEFB	'E'-'@'		; FE2C . Max disk letter
3508:     -	F0F1  0F      		DEFB	15		; FE2D . Max user number
3509:     -	F0F2  01      		DEFB	1		; FE2E . 1=ok to accept DU:, 0=not ok
3510:     -	F0F3  00      		DEFB	0		; FE2F . CRT selection
3511:     -	F0F4  00      		DEFB	0		; FE30 . Printer selection
3512:     -	F0F5  50      		DEFB	80		; FE31 . CRT 0: Width
3513:     -	F0F6  1D      		DEFB	29		; FE32 	 # of lines
3514:     -	F0F7  1B      		DEFB	27		; FE33 	 # of text lines
3515:     -	F0F8  1F00    		DEFW	001FH		; FE34 . Valid drive vector (A-E)
3516:     -	F0FA  00      		DEFB	0		; FE36 . spare
3517:     -	F0FB  50      		DEFB	80		; FE37 . PRT 0: Width
3518:     -	F0FC  42      		DEFB	66		; FE38 	 # of lines
3519:     -	F0FD  3A      		DEFB	58		; FE39 	 # of text lines
3520:     -	F0FE  01      		DEFB	1		; FE3A 	 FF flag (1=can form feed)
3521:     -	F0FF  00      		DEFB	0		; FE3B . spare
3522:     -	F100  00      		DEFB	0		; FE3C . spare
3523:     -	F101  00      		DEFB	0		; FE3D . spare
3524:     -	F102  00      		DEFB	0		; FE3E . spare
3525:     -	F103  00CC    		DEFW	CCP		; FE3F . CCP address
3526:     -	F105  10      		DEFB	16		; FE41 . CCP size in records
3527:     -	F106  06D4    		DEFW	BDOS		; FE42 . BDOS address
3528:     -	F108  1C      		DEFB	28		; FE44 . BDOS size in records
3529:     -	F109  00E2    		DEFW	BIOS		; FE45 . BIOS address
3530:     -	F10B  53482020		DEFB	'SH      '	; FE47 . Shell variable filename
	              20202020
3531:     -	F113  564152  		DEFB	'VAR'		;      . Shell variable filetype
3532:     -	F116  20202020		DEFB	'        '	; FE52 . File 1
	              20202020
3533:     -	F11E  202020  		DEFB	'   '		; 
3534:     -	F121  20202020		DEFB	'        '	; FE5D . File 2
	              20202020
3535:     -	F129  202020  		DEFB	'   '		; 
3536:     -	F12C  20202020		DEFB	'        '	; FE68 . File 3
	              20202020
3537:     -	F134  202020  		DEFB	'   '		; 
3538:     -	F137  20202020		DEFB	'        '	; FE73 . File 4
	              20202020
3539:     -	F13F  202020  		DEFB	'   '		; 
3540:     -	F142  00      		DEFB	0		; FE7E Public drive area (ZRDOS +)
3541:     -	F143  0F      		DEFB	15		; FE7F Public user area (ZRDOS +)
3542:								; ENV 128 bytes long
3543:				
3544:     -	F144          	ENV2:		;1234567890123		; Terminal capabilities data
3545:     -	F144  4445432D		DB	'DEC-VT100    '		;Name of Terminal
	              56543130
	              30202020
	              20
3546:     -	F151  54      		DB	ENV2$G-ENV2		; graphics offset
3547:     -	F152  80      		DB	80H			; config byte B14
3548:     -	F153  10      		DB	10H			; config byte B15
3549:     -	F154  05      		DB	'E'-'@'			;Cursor UP (Wordstar Defaults)
3550:     -	F155  18      		DB	'X'-'@'			;Cursor DOWN
3551:     -	F156  04      		DB	'D'-'@'			;Cursor RIGHT
3552:     -	F157  13      		DB	'S'-'@'			;Cursor LEFT
3553:     -	F158  32      		DB	50			;CL Delay
3554:     -	F159  05      		DB	5			;CM Delay
3555:     -	F15A  03      		DB	3			;CE Delay
3556:     -	F15B  1B5B324A		DB	1bh,'[2J',0		;CL String
	              00
3557:     -	F160  1B5B2569		DB	1bh,'[%i%d;%dH',0	;CM String
	              25643B25
	              644800
3558:     -	F16B  1B5B4B00		DB	1bh,'[K',0		;CE String
3559:     -	F16F  1B5B316D		DB	1bh,'[1m',0		;SO String
	              00
3560:     -	F174  1B5B6D00		DB	1bh,'[m',0		;SE String
3561:     -	F178  00      		DB	0			;TI String
3562:     -	F179  00      		DB	0			;TE String
3563:     -	F17A  1B5B4D00		DB	1bh,'[M',0		;DL line delete
3564:     -	F17E  1B5B4C00		DB	1bh,'[L',0		;IL line insert
3565:     -	F182  1B5B4A00		DB	1bh,'[J',0		;CD clear to end of screen
3566:     -	F186  1B5B252B		DB	1bh,'[%+0m',0
	              306D00
3567:     -	F18D  30353734		DB	'0574',0
	              00
3568:     -	F192  1B5B366E		DB	1bh,'[6n',0		;read current cursor position
	              00
3569:     -	F197  00      		DB	0			;read line until cursor
3570:     -	F198  00      	ENV2$G:	DB	0			;GO graphics on/off delay
3571:     -	F199  0E00    		DB	0eh,0			;GS graphics on
3572:     -	F19B  0F00    		DB	0fh,0			;GE graphics off
3573:     -	F19D  1B5B3F32		DB	1bh,'[?25l',0		;CDO cursor off
	              356C00
3574:     -	F1A4  1B5B3F32		DB	1bh,'[?25h',0		;CDE cursor on
	              356800
3575:     -	F1AB  DA      		DB	0DAH			; GULC upper left corner
3576:     -	F1AC  BF      		DB	0BFH			; GURC upper right corner
3577:     -	F1AD  C0      		DB	0C0H			; GLLC lower left corner
3578:     -	F1AE  D9      		DB	0D9H			; GLrC lower right corner
3579:     -	F1AF  C4      		DB	0C4H			; GHL horizontal line
3580:     -	F1B0  B3      		DB	0B3H			; GVL vertical line
3581:     -	F1B1  DB      		DB	0DBH			; GFB full block
3582:     -	F1B2  B1      		DB	0B1H			; GHB hashed block
3583:     -	F1B3  C2      		DB	0C2H			; GUI upper intersection
3584:     -	F1B4  C1      		DB	0C1H			; GLI lower intersection
3585:     -	F1B5  C5      		DB	0C5H			; GIS intersection
3586:     -	F1B6  B4      		DB	0B4H			; GRTI right intersection
3587:     -	F1B7  C3      		DB	0C3H			; GLTI left intersection
3588:     -	F1B8  00      		DB	0			;
3589:     -	F1B9          	ENVEND:
3590:				
3591:				; End of environment and TCAP descriptors
3592:				
3593:     -	F1B9  04FF    	CMDSET:	DEFW	Z3CL+4		; Point to first chr in cmd line buf
3594:     -	F1BB  C8      		DEFB	Z3CLS		; Command line buffer size
3595:     -	F1BC          	CMDSET$END	EQU	$
3596:				
3597:     -	F1BC          	PATH:				; Initial path description
3598:     -	F1BC  2424    		DEFB	'$$'		; .  Current drive, current user 
3599:     -	F1BE  010F    		DEFB	1,15		; .  Drive A:, user 15
3600:     -	F1C0  00      		DEFB	0		; (end of path)
3601:     -	F1C1          	PATH$END	EQU	$
3602:				
3603:     -	F1C1          	DRIVE$TDATA:
3604:								; Drive type data
3605:     -	F1C1  01020408		DEFB	01H,02H,04H,08H
3606:     -	F1C5  02000000		DEFB	02H,00H,00H,00H
3607:				
3608:     -	F1C9          	LAST$SG EQU	$
3609:				
3610:     -	EF0B          		ORG	BOOT
3611:				
3612:     -	EF0B          	UNINIT	EQU	$
3613:     -	EF0B          	MUNACT:	ds	1		; UNALLOCATED COUNT VALUE
3614:     -	EF0C          	SEKDSK:	ds	1		; SEEK DISK NUMBER
3615:     -	EF0D          	SEKTRK:	ds	2		; SEEK TRACK NUMBER
3616:     -	EF0F          	SEKSEC:	ds	1		; SEEK SECTOR NUMBER
3617:				
3618:     -	EF10          	HSTDSK:	ds	1		; HOST DISK NUMBER
3619:     -	EF11          	HSTTRK:	ds	2		; HOST TRACK NUMBER
3620:     -	EF13          	HSTSEC:	ds	1		; HOST SECTOR NUMBER
3621:				
3622:     -	EF14          	CPMDSK:	ds	1		; SINGLE DENSITY	DSK PARM
3623:     -	EF15          	CPMTRK:	ds	2		; AND TRK
3624:     -	EF17          	CPMSEC:	ds	1		; AND SECTOR
3625:				
3626:     -	EF18          	SEKHST:	ds	1		; SEEK SHR SECSHF
3627:     -	EF19          	HSTACT:	ds	1		; HOST ACTIVE FLAG
3628:     -	EF1A          	HSTWRT:	ds	1		; HOST WRITTEN FLAG
3629:				
3630:     -	EF1B          	UNACNT:	ds	1		; UNALLOC REC CNT
3631:     -	EF1C          	UNADSK:	ds	1		; LAST UNALLOC DISK
3632:     -	EF1D          	UNATRK:	ds	2		; LAST UNALLOC TRACK
3633:     -	EF1F          	UNASEC:	ds	1		; LAST UNALLOC SECTOR
3634:				
3635:     -	EF20          	CPMSPT:	ds	1		; LOGICAL SECTORS PER TRACK
3636:     -	EF21          	SECMSK:	ds	1		; SECTOR MASK
3637:     -	EF22          	SECSHF:	ds	1		; SECTOR SHIFT
3638:				
3639:     -	EF23          	INT$RETRIES:
3640:     -	EF23          		ds	1		; Internal retry counter for RD & WR
3641:     -	EF24          	ERFLAG:	ds	1		; ERROR REPORTING
3642:     -	EF25          	RSFLAG:	ds	1		; READ SECTOR FLAG
3643:     -	EF26          	READOP:	ds	1		; 1 IF READ OPERATION
3644:     -	EF27          	WRTYPE:	ds	1		; WRITE OPERATION TYPE
3645:     -	EF28          	DMAADR:	ds	2		; LAST DMA ADDRESS
3646:     -	EF2A          	HSTBUF:	ds	1024		; HOST BUFFER
3647:     -	F32A          	STATUS:	ds	1
3648:     -	F32B          	MESSAGE:ds	1
3649:     -	F32C          	CMDPTR:	ds	2
3650:     -	F32E          	DATPTR:	ds	2
3651:     -	F330          	LOGDSK:	ds	1
3652:     -	F331          	PHYDRV:	ds	1
3653:     -	F332          	DPHDRV:	ds	1
3654:     -	F333          	PHYTAG:	ds	2
3655:     -	F335          	PHYCMD:	ds	1
3656:     -	F336          	TAGDRV:	ds	1
3657:     -	F337          	TAGPHY:	ds	1
3658:     -	F338          	TAGTYP:	ds	1
3659:     -	F339          	TAGCTL:	ds	1
3660:     -	F33A          	S$IO$COUNT:
3661:     -	F33A          		ds	1
3662:     -	F33B          	S$STAT$DAT:
3663:     -	F33B          		ds	4
3664:     -	F33F          	TARGET:	ds	1
3665:     -	F340          	LOGUNIT:ds	1
3666:     -	F341          	CURDPB:	ds	2
3667:				
3668:				;	AMPRO BIOS-SPECIFIC STORAGE
3669:				
3670:     -	F343          	IDSAVE:	ds	6		; READ ADDRESS BUFFER AREA
3671:     -	F349          	LTRACK:	ds	5		; LAST FLOPPY TRACK ACCESSED
3672:     -	F34E          	LDISK:	ds	1		; LAST DISK SELECTED
3673:     -	F34F          	TRIES:	ds	1		; NUMBER OF TIMES TO DO IT
3674:     -	F350          	RWHOST:	ds	1		; LOCAL READ/WRITE FLAG
3675:     -	F351          	HSTSID:	ds	1		; HOST DISK SIDE SELECT MASK
3676:     -	F352          	TIMEOUT:ds	1		; TIMEOUT LOOP COUNTER
3677:     -	F353          	SECTOR:	ds	1		; TEMPORARY STORAGE
3678:				
3679:     -	F354          	CHGDSK:	ds	1		; Flag to tell if we changed drives
3680:     -	F355          	FRWCMD:	ds	1		; FDC command
3681:     -	F356          	FRWPTR:	ds	2		; FDC data pointer
3682:     -	F358          	SAVE$CMDPTR:
3683:     -	F358          		ds	2		; SCSI command pointer save area
3684:     -	F35A          	SAVE$DATPTR:
3685:     -	F35A          		ds	2		; SCSI data pointer save area
3686:				
3687:				;	SPECIAL E DISK PARAMETERS - FILLED IN WHEN E DISK IS
3688:				;	FIRST SELECTED, AND USED IN DEBLOCKING.
3689:				
3690:     -	F35C          	ESECADJ:ds	1		; SECTOR NUMBER ADJUST FOR SIDE 1
3691:				
3692:     -	F35D          	KEYBUF:	ds	KEYSIZE		; allocate buffer space for 64 chars
3693:     -	009D          	KEYSTOP EQU	($ & 255)	; end of buffer address
3694:				
3695:     -	F39D          	MdmObuf:
3696:     -	F39D          		ds	MdmOsize	; space for 200 characters to modem
3697:     -	0047          	MdmOstop	equ	($ & 255)
3698:				;
3699:     -	F447          	MdmIbuf:
3700:     -	F447          		ds	MdmIsize	; space for 200 characters from modem
3701:     -	00F1          	MdmIstop	equ	($ & 255)
3702:				;
3703:     -	F4F1          	DIRBUF:	ds	128		; DIRECTORY ACCESS BUFFER
3704:				
3705:				;	*	*	*	*	*	*	*	*
3706:				;
3707:				;  Floppy drive directory check vector storage
3708:				;
3709:				;  The length of these vectors allows the use of up to 256
3710:				;  directory entries, all of which are checked by BDOS.
3711:				;
3712:				;  Note that these are used for removable floppy media only.
3713:				;
3714:				;  Do not change QPARM to increase the number of directory
3715:				;  entries without adjusting the variable FD$CKS.
3716:				;
3717:				;	*	*	*	*	*	*	*	*
3718:     -	0040          	QD$CKS	EQU	(255/4)+1	; maximum of 256 directory entries 
3719:     -	0020          	DS$CKS	EQU	(127/4)+1	; maximum of 128 directory entries
3720:				
3721:     -	F571          	CSVA:	ds	QD$CKS
3722:     -	F5B1          	CSVB:	ds	DS$CKS
3723:     -	F5D1          	CSVC:	;	ds	FD$CKS
3724:     -	F5D1          	CSVD:	;	ds	FD$CKS
3725:     -	F5D1          	CSVE:	ds	QD$CKS
3726:				
3727:				;	*	*	*	*	*	*	*	*
3728:				;
3729:				;  Floppy drive allocation vector storage
3730:				;
3731:				;  This area is used by BDOS to map all CP/M blocks for the
3732:				;  target disk drive, and is maintained to indicate which blocks
3733:				;  on the disk are in use.
3734:				;
3735:				;  The length of the Floppy area is set to 50 Bytes, which is
3736:				;  enough to handle a 96 TPI DS/DD disk as described in QPARM.
3737:				;
3738:				;  Do not change QPARM to increase storage without adjusting
3739:				;  the variable FD$ALV.
3740:				;
3741:				;	*	*	*	*	*	*	*	*
3742:     -	0032          	QD$ALV	EQU	(394/8)+1	; maximum of 395 disk blocks
3743:     -	0019          	DS$ALV	EQU	(194/8)+1	; maximum of 195 disk blocks
3744:				
3745:     -	F611          	ALVA:	ds	QD$ALV		; A: is an 80 tracker, needs max
3746:     -	F643          	ALVB:	ds	QD$ALV		; B: is an 80 tracker, needs max
3747:     -	F675          	ALVC:	;	ds	SS$ALV
3748:     -	F675          	ALVD:	;	ds	SS$ALV
3749:     -	F675          	ALVE:	ds	QD$ALV
3750:				
3751:     -	F6A7          	FDATAEND EQU	$
3752:     -	F6A7          	HD$VECTORS EQU	$		; HD check & allocation vectors 
3753:				
3754:				;	*	*	*	*	*	*	*	*
3755:				;
3756:				;  Hard disk directory check vector storage
3757:				;
3758:				;	No Check storage is required - just an address
3759:				;
3760:				;	*	*	*	*	*	*	*	*
3761:				CSVF:	ds	0
3762:				CSVG:	ds	0
3763:				CSVH:	ds	0
3764:				CSVI:	ds	0
3765:				CSVJ:	ds	0
3766:				CSVK:	ds	0
3767:				CSVL:	ds	0
3768:				CSVM:	ds	0
3769:				CSVN:	ds	0
3770:				CSVO:	ds	0
3771:				CSVP:	ds	0
3772:				;	*	*	*	*	*	*	*	*
3773:				;
3774:				;  Hard disk allocation vector storage
3775:				;
3776:				;	*	*	*	*	*	*	*	*
3777:     -	00A0          	HD$ALV	EQU	(1279/8)+1	; Maximum 1280 disk blocks
3778:				ALVF:	ds	0
3779:				ALVG:	ds	0
3780:				ALVH:	ds	0
3781:				ALVI:	ds	0
3782:				ALVJ:	ds	0
3783:				ALVK:	ds	0
3784:				ALVL:	ds	0
3785:				ALVM:	ds	0
3786:				ALVN:	ds	0
3787:				ALVO:	ds	0
3788:				ALVP:	ds	0
3789:				
3790:     -	F6A7          	HD$CURRENT EQU	$		; Current Bios Buffer Area ptr
3791:				
3792:     -	F6A7          	ENDDATA EQU	$
3793:								; Mark the last avail. byte
3794:     -	F6DC          	RESERVE EQU	Z3BASE-2*256-36	; 0F900H is ZCPR3 base, minus 256 bytes for
3795:								; each 8M hard drive, and 36 bytes for
3796:								; external NovaDOS stack at ZCPR3 base
3797:				
3798:     -	0DE5          	FDCSIZE EQU	(MAINEND-BIOS) + (LAST$SG-HDCODE)
3799:     -	04DE          	FDDSIZE EQU	FDATAEND-LAST$SG
3800:				
3801:     -	01E4          	HDCSIZE EQU	HDCODE-MAINEND
3802:     -	0000          	HDDSIZE EQU	ENDDATA-FDATAEND
3803:				
3804:				;	*	*	*	*	*	*	*	*
3805:				;
3806:				;  Show the available free space and the number of sectors needed
3807:				;  to hold a SYSGEN image of CP/M with this BIOS:
3808:				;
3809:				;	*	*	*	*	*	*	*	*
3810:     -	0035          	FREEMEM EQU	RESERVE-ENDDATA	; Free memory left
3811:				
3812:     -	004C          	SGSIZE	EQU	(LAST$SG-CCP+127)/128 ; Sysgen size
3813:								; Number of sectors -- Must be 50H or less!
3814:				
3815:     -	F6A7          		END			; BIOS



Statistics:

     4	passes
     0	jr promotions
   532	symbols
  4007	bytes



Symbol Table:

ALL$DONE        EE4D      61005
ALLOC           E70F      59151
ALVA            F611      62993
ALVB            F643      63043
ALVC            F675      63093
ALVD            F675      63093
ALVE            F675      63093
ALVF            F6A7      63143
ALVG            F6A7      63143
ALVH            F6A7      63143
ALVI            F6A7      63143
ALVJ            F6A7      63143
ALVK            F6A7      63143
ALVL            F6A7      63143
ALVM            F6A7      63143
ALVN            F6A7      63143
ALVO            F6A7      63143
ALVP            F6A7      63143
AUTCMD$END     =E26C      57964
AUTOCMD         E262      57954
BDOS           =D406      54278
BELL           =07        7
BIAS           =9800      38912
BIOS           =E200      57856
BLD$S$SCTR      EDF6      60918
BOOT            EF0B      61195
BOOTMSG         E5A4      58788
BSP            =08        8
BSYBIT         =08        8
BUFTBL          E7D5      59349
BUSBSY         =40        64
CAN            =18        24
CCP            =CC00      52224
CDISK          =04        4
CHGDSK          F354      62292
CHKUNA          E6DE      59102
CLEAR$ARBIT     EE1B      60955
CLKCHK          EC9C      60572
CLKEXT          ECCB      60619
CMDPTR          F32C      62252
CMDSET          F1B9      61881
CMDSET$END     =F1BC      61884
CMND           =C0        192
CONIN           EA8D      60045
CONIN1          EA94      60052
CONOUT          EAA1      60065
CONOUT1         EAA8      60072
CONPEEK         EA5C      59996
CONST           EA7D      60029
CONST1          EA84      60036
CONT           =00        0
CPMDSK          EF14      61204
CPMSEC          EF17      61207
CPMSPT          EF20      61216
CPMTRK          EF15      61205
CPY$TBL         E40F      58383
CR             =0D        13
CRTIN           EAD6      60118
CRTIST          EAC5      60101
CRTOST          EAB1      60081
CRTOUT          EACD      60109
CRTPEEK         EA6A      60010
CRTRDY          EAC2      60098
CSVA            F571      62833
CSVB            F5B1      62897
CSVC            F5D1      62929
CSVD            F5D1      62929
CSVE            F5D1      62929
CSVF            F6A7      63143
CSVG            F6A7      63143
CSVH            F6A7      63143
CSVI            F6A7      63143
CSVJ            F6A7      63143
CSVK            F6A7      63143
CSVL            F6A7      63143
CSVM            F6A7      63143
CSVN            F6A7      63143
CSVO            F6A7      63143
CSVP            F6A7      63143
CTC0            E240      57920
CTC1            E242      57922
CTC2            E244      57924
CTC3            E246      57926
CTCA0          =40        64
CTCA1          =50        80
CTCA2          =60        96
CTCA3          =70        112
CTCINT          E310      58128
CTCVAL          E240      57920
CTRLC          =03        3
CTS            =20        32
CTSoff          EC68      60520
CTSon           EC6C      60524
CURDPB          F341      62273
DATPTR          F32E      62254
DCD            =08        8
DDLSPT         =28        40
DEL            =7F        127
DELSEND        =1C        28
DIRBUF          F4F1      62705
DISKE           E4E5      58597
DLOOP           E8FA      59642
DMAADR          EF28      61224
DPARM           E327      58151
DPBASE          E280      57984
DPBTBL          E657      58967
DPHDRV          F332      62258
DRIVE$TDATA     F1C1      61889
DRIVE$TYPES     E270      57968
DRVR3           ED6B      60779
DRVRADR         E456      58454
DS$ALV         =19        25
DS$CKS         =20        32
DSBIAS         =10        16
DSDD48         =C6        198
DSDD96         =C7        199
DWAIT           E8F5      59637
E$IS$DD         E512      58642
EDSD            E369      58217
EMATCH          E6FD      59133
ENDDATA        =F6A7      63143
ENV             F0C4      61636
ENV1            F0C7      61639
ENV2            F144      61764
ENV2$G          F198      61848
ENVEND          F1B9      61881
EPARM           E35A      58202
ERFLAG          EF24      61220
ERROR          =02        2
ESC            =1B        27
ESECADJ         F35C      62300
ETYPE           E359      58201
EXIT            ED13      60691
EXPATH         =40        64
EXPATHS        =05        5
EXTFCB         =FDD0      64976
EXTSTK         =FFD0      65488
FCP            =F900      63744
FCPS           =06        6
FDATAEND       =F6A7      63143
FDCSIZE        = DE5      3557
FDDSIZE        = 4DE      1246
FILHST          E75D      59229
FLOPPY          E7E5      59365
FLOPPYIO        E7E9      59369
FNP            =02        2
FNS            =08        8
FPARM           ED27      60711
FRDADDR        =C8        200
FREADS         =88        136
FREEMEM        =35        53
FRESTOR        =08        8
FRETRY         =03        3
FRWCMD          F355      62293
FRWPTR          F356      62294
FSEEK          =1C        28
FSEEKNV        =18        24
FVF            =04        4
FWRITES        =A8        168
GET$AD          E99D      59805
GETBUF          EA34      59956
GETDPT          E638      58936
GETEDSK         E3A8      58280
GETSEC          EA02      59906
GETSTEP         E993      59795
GETTBL          E384      58244
GETTRK          EA41      59969
GETTRK1         EA56      59990
GETTRK2         EA58      59992
GETTYPE         E9F8      59896
GOCPM           E56D      58733
GOTSDS          EA10      59920
GPARM           ED37      60727
GSEXIT          EA31      59953
HD$ALV         =A0        160
HD$ALV$AVAIL    E3EE      58350
HD$BYTE$BLOCK   ED48      60744
HD$CURRENT     =F6A7      63143
HD$DPB$BASE    =ED27      60711
HD$DPB$LEN     =20        32
HD$INFO         E3EA      58346
HD$VECTORS     =F6A7      63143
HDCODE         =EF0B      61195
HDCSIZE        = 1E4      484
HDDSIZE        =00        0
HIGH$ADDR       ED66      60774
HLDELAY        =23        35
HOME            E466      58470
HOMED           E475      58485
HOSTDO          E7CF      59343
HOSTIO          E7D2      59346
HRCNT           ECEC      60652
HSA             E26C      57964
HSB             E26D      57965
HSTACT          EF19      61209
HSTBUF          EF2A      61226
HSTDSK          EF10      61200
HSTSEC          EF13      61203
HSTSID          F351      62289
HSTTRK          EF11      61201
HSTWRT          EF1A      61210
IDSAVE          F343      62275
INT$RETRIES     EF23      61219
IOBYT           E261      57953
IOBYTE         =03        3
IOINIT          E3AC      58284
IOP            =00        0
IOPS           =00        0
JULCNT          ECEA      60650
KEYBUF          F35D      62301
KEYCHK          EBEF      60399
KEYEND          ED1A      60698
KEYEXT          EC06      60422
KEYSIZE        =40        64
KEYST           ED18      60696
KEYSTOP        =9D        157
LAST$SG        =F1C9      61897
LDISK           F34E      62286
LF             =0A        10
LIST1           EBA3      60323
LISTST          EB84      60292
LOCSTK          ED0F      60687
LOGDSK          F330      62256
LOGMSG          EFAD      61357
LOGUNIT         F340      62272
LOW$ADDR        ED68      60776
LPTOUT          EBB7      60343
LPTST           EBC4      60356
LSTOUT          EB9C      60316
LSTST1          EB8B      60299
LSTST2          EB95      60309
LTRACK          F349      62281
M$UNACT$TBL     E663      58979
MAINEND        =ED27      60711
MAP$AD          E9BF      59839
MAPTRK          E9B5      59829
MAPTYPE         E9A8      59816
MATCH           E780      59264
MATMOR          E73B      59195
MAX$DRV$LTR     E25C      57948
MED$ADDR        ED67      60775
MESSAGE         F32B      62251
MINCNT          ECED      60653
MORUNA          E6ED      59117
MOTOR           E8BF      59583
MOTOROK         E8F3      59635
MSIZE          =3A        58
MUNACT          EF0B      61195
MY$ID           ED47      60743
MdmIbuf         F447      62535
MdmIend         ED1F      60703
MdmIlen         ED21      60705
MdmIsize       =AA        170
MdmIst          ED1D      60701
MdmIstop       =F1        241
MdmObuf         F39D      62365
MdmOend         ED24      60708
MdmOlen         ED26      60710
MdmOsize       =AA        170
MdmOst          ED22      60706
MdmOstop       =47        71
NAK            =15        21
NCRBASE        =20        32
NCRBSR         =25        37
NCRBSY         =40        64
NCRCD          =08        8
NCRCSBS        =24        36
NCRCSD         =20        32
NCRDACK        =28        40
NCRDBP         =01        1
NCRICR         =21        33
NCRIDR         =26        38
NCRIO          =04        4
NCRMR          =22        34
NCRMSG         =10        16
NCRODR         =20        32
NCRREQ         =20        32
NCRRPI         =27        39
NCRRST         =80        128
NCRSDIR        =27        39
NCRSDS         =25        37
NCRSDTR        =26        38
NCRSEL         =02        2
NCRSER         =24        36
NCRTCR         =23        35
NEXT$BIT        EF3F      61247
NEXT$BLIP       E92A      59690
NOBIAS          E820      59424
NODS1           E95C      59740
NODS2           E96A      59754
NOMATCH         E74A      59210
NOOVF           E709      59145
NOT7            EF45      61253
NOTCONT         E684      59012
NSECTS         =10        16
NXTJMP          E389      58249
NXTSEC          E56B      58731
NXTTBL          E38A      58250
OC0             E8B7      59575
OC1             E8BB      59579
OLDSTK          ED11      60689
OUTCMD          E8B4      59572
PAGET           E405      58373
PATH            F1BC      61884
PATH$END       =F1C1      61889
PATMV           E3E0      58336
PDRVR           E4A6      58534
PDRVR1          E4D0      58576
PEEKCHR         EA7A      60026
PHASE$TABLE     EE96      61078
PHASE0          EEA6      61094
PHASE1          EEAF      61103
PHASE2          EEB8      61112
PHASE3          EEBF      61119
PHASE4          EECD      61133
PHASE5          EECD      61133
PHASE6          EECD      61133
PHASE7          EEC6      61126
PHTBAC          E3FA      58362
PHYCMD          F335      62261
PHYDRV          F331      62257
PHYEND         =E466      58470
PHYTAB          E416      58390
PHYTAG          F333      62259
PIO1           =01        1
PRTRDY         =10        16
PUNCH           EB06      60166
PUTS            E51B      58651
QD$ALV         =32        50
QD$CKS         =40        64
QPARM           E336      58166
RCP            =00        0
RCPS           =00        0
RD              E894      59540
RDA            =01        1
RDAT           =C7        199
RDATA           E882      59522
RDATA2          E88B      59531
RDDONE          E8A2      59554
RDNCD           E8A6      59558
RDS             E83C      59452
READ            E699      59033
READER          EB2B      60203
READHST         E7CD      59341
READOP          EF26      61222
RESERVE        =F6DC      63196
RESTORE         E911      59665
RSCSI           EEF2      61170
RSCSI1          EEF7      61175
RSCSI2          EF02      61186
RSEC           =C6        198
RSFLAG          EF25      61221
RTRK           =C5        197
RWFAIL          E845      59461
RWHOST          F350      62288
RWMOVE          E7A6      59302
RWOPER          E717      59159
S$CMD           ED9F      60831
S$CMD$RETRY     EDAB      60843
S$DO$RW         ED8E      60814
S$DONE          EDF4      60916
S$END$ERR       ED5D      60765
S$END$OK        ED5C      60764
S$EXIT          EECD      61133
S$HSPEED        ED4B      60747
S$ID$FOUND      F041      61505
S$INT           EE6E      61038
S$IO            ED84      60804
S$IO$COUNT      F33A      62266
S$PHASE         EE77      61047
S$RD            ED8C      60812
S$RD$CMD       =08        8
S$RDY           EE60      61024
S$RW$CMD        ED65      60773
S$STAT$CMD      ED5F      60767
S$STAT$DAT      F33B      62267
S$WR            ED88      60808
S$WR$CMD       =0A        10
SAVE$CMDPTR     F358      62296
SAVE$DATPTR     F35A      62298
SCSI            ED49      60745
SDONE           E687      59015
SEC$MSK$TBL     E65F      58975
SECMSK          EF21      61217
SECNT           ECEE      60654
SECSHF          EF22      61218
SECTOR          F353      62291
SECTRAN         E48D      58509
SEEK            E949      59721
SEKDSK          EF0C      61196
SEKHST          EF18      61208
SEKSEC          EF0F      61199
SEKTRK          EF0D      61197
SELDSK          E490      58512
SELECT          EE16      60950
SELECT$OK       EE4C      61004
SELEDSK         E667      58983
SELEND          E616      58902
SELERR          E4E1      58593
SELESHIFT       E67A      59002
SELFLP          E5B3      58803
SELSS           E5E6      58854
SET$DSTEP       E611      58897
SETDMA          E487      58503
SETSEC          E47F      58495
SETTRK          E476      58486
SETUP           E9C7      59847
SETUP2          E9E9      59881
SGSIZE         =4C        76
SHSIZE         =20        32
SHSTK          =FD00      64768
SHSTKS         =04        4
SIOALNG        =09        9
SIOAR1          E250      57936
SIOAR3          E24C      57932
SIOAR4          E24A      57930
SIOAR5          E24E      57934
SIOAVAL         E248      57928
SIOBLNG        =0B        11
SIOBR1          E25B      57947
SIOBR2          E253      57939
SIOBR3          E257      57943
SIOBR4          E255      57941
SIOBR5          E259      57945
SIOBVAL         E251      57937
SIOCPA         =84        132
SIOCPB         =8C        140
SIODPA         =80        128
SIODPB         =88        136
SIOINT          E300      58112
SLOOP           E722      59170
SPARM           E318      58136
SSDD48         =86        134
SSDD96         =87        135
STAT           =C4        196
STATUS          F32A      62250
STBCLR         =03        3
STBSET         =02        2
STEP$RATE       ED6A      60778
STIM            EE37      60983
STPRAT          E25D      57949
SWAP            E3D4      58324
SYSDSK          E23F      57919
SioAstatus      EC4F      60495
SioBstatus      EC76      60534
TAB            =09        9
TAGCTL          F339      62265
TAGDRV          F336      62262
TAGPHY          F337      62263
TAGTYP          F338      62264
TARGET          F33F      62271
TBE            =04        4
TIMEOUT         F352      62290
TOD             ECD0      60624
TODRD           ECE5      60645
TRIES           F34F      62287
TTYBLP          EB6F      60271
TTYBRK          EB5B      60251
TTYIN           EB2B      60203
TTYIST          EAFE      60158
TTYOST          EAF5      60149
TTYOUT          EB06      60166
TTYPEEK         EA73      60019
TYPTBL          E653      58963
UABORT          E946      59718
UNACNT          EF1B      61211
UNADSK          EF1C      61212
UNASEC          EF1F      61215
UNATRK          EF1D      61213
UNINIT         =EF0B      61195
VECTORS         E300      58112
VERS           =2B        43
WAIT            E9ED      59885
WAIT1           E9EE      59886
WAIT2           E9F0      59888
WAITMORE        E8DE      59614
WBERR           E59C      58780
WBLOOP          E542      58690
WBOOT           E525      58661
WBOOTE          E203      57859
WDAT           =C3        195
WMI             E7F1      59377
WR              E862      59490
WRALL          =00        0
WRDAT           E854      59476
WRDAT2          E85A      59482
WRDIR          =01        1
WRDONE          E870      59504
WRITE           E6B9      59065
WRITEHST        E7CA      59338
WRNLD           E874      59508
WRTYPE          EF27      61223
WRUAL          =02        2
WSCSI           EED5      61141
WSCSI1          EEDE      61150
WSCSI2          EEE9      61161
WSEC           =C2        194
WTRK           =C1        193
XLTDS           E34F      58191
XLTE1           E36A      58218
XLTSS           E345      58181
Z3BASE         =F900      63744
Z3CL           =FF00      65280
Z3CLS          =C8        200
Z3ENV          =FE00      65024
Z3ENVS         =02        2
Z3MSG          =FD80      64896
Z3NDIR         =FC00      64512
Z3NDIRS        =0E        14
Z3REV          =21        33
Z3WHL          =4B        75
ZBOOT           EF6C      61292
ei$reti         ECCD      60621
keyerr          EBCD      60365
keylen          ED1C      60700
keysts          EC41      60481
krex            EAF3      60147
mdmTxE          EC77      60535
mdmTxE1         EC8E      60558
mdmTxE2         EC93      60563
mdmTxEx         EC97      60567
mdmchk          EC0B      60427
mdmchk1         EC25      60453
mdmctf         =99        153
mdmerr          EBDE      60382
mdmext          EC3C      60476
mdmsts          EC50      60496
punch1          EB19      60185
punch2          EB26      60198
setCTS          EC6E      60526
ttyin1          EB3F      60223
ttyin2          EB58      60248
